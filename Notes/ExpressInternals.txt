1. Express as a function over http.createServer

    - Node provide the HTTP module
    - It can create an HTTP server
    - It listen to the port
    - It receives request  and send response
    - NODE JS IS THE ACTUAL SERVER
    
    - Express is a web framework
    - It is build on top of Node's HTTP module
    - provides routing and middleware
    - But internally
        - Express returns a function
    - Express does
        - Receives req and res
        - Starts its middleware and routing logic
    - Express is simply a function passed into Node's server
    - Node calls Express(as a function)
    - NODE IS THE SERVER, EXPRESS IS THE REQUEST HANDLER
--------------------------------------------------------------------------------
2. Why does node need express

    - node alone
        if (req. meth od === "GET" && req. url  === "/users") {
            ......
        };
    - Express
        app.get("/users" , handler);
    - So Express adds: 
        - Routing abstraction
        - Middleware chain
        - Cleaner code
        - Reusability
--------------------------------------------------------------------------------
3. Express is not a server, Node is

    - What does a server actually means ?
        - A server is something that can
            1. Open a Network port(e.g,. 3000)
            2. Accept a TCP connections
            3. Read raw bytes from the network
            4. Prase protocols (like HTTP)
            5. Send bytes back to the client
        - Node.js provides
            1. TCP sockets (via net module)
            2. HTTP parsing (via http module)
            3. Event loop
            4. OS level async I/O
        - Express does only
            1. Routing (app.get , app.post)
            2. Middleware chaining
            3. Request/Response helpers
--------------------------------------------------------------------------------
4. Express architecture

    1. app (const app = express())
        - app is both a function(Node can call it) and an Object(methods and properties attached)
        - app is instance of a function
        - app.use is typeof function
            eg : function createServer() {
                    function createApp(req, res, next){
                        app.handle(req, res, next)
                    } //function
                    app.use = function use(){} //app treated as object, bounded with methods
                    app.get = function get(){}
                }
        - properties and methods are attached to the functions.
        - In Javascript functions are objects.
        - Internally app holds
            - app._router -> main router
            - app.settings -> configuration (evn, trust proxy)
            - app.locals -> app-level shared variables
    2. router Object
        - express.Router() is mini Express app that can :
            - register routes
            - register middlewares in middleware stack
            - be mounted on the main app
        - It is introduced for
            - Group related routes
            - Isolate logics
            - Build modular, scalable API's
        - type of router is a function
        - Router is a child of app
        - Express treats Router() as a middleware, For matching paths, forward the requests to the router. Router then run its own stack
        - route flow : 
                GET /api/users
                    ↓
                app middleware
                    ↓
                router middleware
                    ↓
                router route handler
    3. middleware stack
        - An Ordered list (array) of middleware layers that Express executes sequentially for a request
        - The middleware stack is core execution model of Express.
        - Its job it to :
            - inspect or modify req
            - inspect or modify res
            - Decide whether to pass control forward
            e.g.
                app.use(logger)
                app.use(auth)
                app.get("/users",handler);

                - Express build something like this (middleware stack)
                    [
                        loggerMiddleware,
                        authMiddleware,
                        usersRouterMiddleware
                    ]
        - Execution model
            1. Express start a index 0 of the stack
            2. Executes the first middleware
            3. That middleware must call next()
            4. Express moves to next middleware
            5. This will continue till: 
                - A response is sent OR The stack ends

                            Request
                                ↓
                            [ Middleware 1 ]
                                ↓ next()
                            [ Middleware 2 ]
                                ↓ next()
                            [ Route Handler ]
                                ↓ res.send()
                            Response
--------------------------------------------------------------------------------
5. app vs router internals

    1. express() vs express.Router()
        - app
            - app is the root express application
            - the entry point for all http requests 
            - the only object that :
                - can start a server
                - can integrate with Node's http layer
        - router
            - A modular, mountable request handler
            - designed only to:
                - Group routes
                - Group middlewares

        eg : function createApp() {
                function app(req, res, next) {
                    app.handle(req, res, next)
                }

                app._router = new Router();
                app.listen = function listen() {}

                return app;
            }

            function Router(){
                function router(req, res, next){
                    router.handle(req, res, next)
                }

                router.stack = [];
                return router;
            }
    2. use router for feature based API's and use app for small/temporary/POC api's
    3. Modular routing : organizing routes
        - Maintainability
        - Team scalability
        - Testability
--------------------------------------------------------------------------------
6. Router mounting basics

    1. app.use("/api" , router)
        - Router mounting : It means attaching a router as a middleware at a specific path prefix.
        - Here, For any request starting with /api, pass control to the router. 
        - when you mount a router
            - (req, res, next) => router.handle(req, res, next)
            - So router becomes one middleware layer inside the app's middleware stack
            - eg : -> Path : /api/user/active/:id
                    app -> /api -> routeHandler (/user/active/:id)
                    routeHandler -> /user -> activeRequestHandler (/active/:id)
                    activeRequestHandler -> /active/:id -> service logic and returns the response.
    2. req.url vs req.baseUrl
        - req.url 
            - The current URL path that Express is processing (after prefix stripping by mounted routers)
            - changes as request moves through router
            - Relative to the current router
        - req.baseUrl
            - The mount path on which the current router was mounted
            - set by Express during router mounting
            - Does not change inside the router
                -> GET /api/users/:id
                    {
                        "/api" : {
                            "/users" : { 
                                "/" : fn(){},
                                "/:id" : fn(){}
                            } 
                        }
                    }
                -> /api is baseUrl for /users (url)
                -> /api/users is baseUrl for / and /:id (url)
                -> GET /api/users
                -> url: /users and baseUrl: /api
        - req.originalUrl 
            - The complete path
        eg :  
            -> GET /api/orders/1
            app.use("/api", apiRouter);
            app.use("/orders" , ordersRouter);
            api.get("/:id" , () => {});

            orderRouter req.url -> /1 -> remaining path of router
            orderRouter req.BaseUrl -> /api/orders -> where the router is mounted
            orderRouter req.originalUrl -> /api/orders/1 -> complete url

        - req.originalUrl === req.baseUrl + req.url
        - req.originalUrl is the untouched original path, while req.baseUrl + req.url explain how Express got there.
--------------------------------------------------------------------------------
7. Route matching & execution order

    1. HTTP method matching
        - Express executes a router handler only if the HTTP method matches with route's declared method
            e.g : app.get("/users" , routeHandler)
                  app.post("/users" , routerHandler)
        - HTTP method comes from Node.js (req.method), Node parses it from HTTP request.
        - app.use() does not care about HTTP methods, It matches all methods, Generally used for method-agnostic middleware
            e.g : Auth middleware often uses use()
    2. Path matching
        - The Path matching is a process by which Express compare the request URL with a registered route path to decide whether a handler should run.
        - Query String are excluded in Path Matching

        e.g :   app.get("/users" , routeHandler)
                    - Matches 
                        GET /users
                    - Does not match
                        GET /users/
                        GET /users/42

                app.get("/users/:id" , routeHandler)
                    - Matches 
                        GET /users/42
                        GET /users/abc
                    - req.param ={ id : 42 }
                    - Does not match
                        GET /users
                        GET /users/42/profile    
                
                app.get("/users/:userId/orders/:orderId, handler)
                    - Matches
                        GET /users/10/orders/1
                        - req.params = { userId : 10, orderId : 1 }

                - WildCard match (*)
                    app.get("/files/*", handler) 
                        - Matches
                            GET /files/a.txt
                            GET /files/images/logo.png
                        - Matches anything after that point

                - Optional parameter
                    app.get("/users/:id?",handler)
                        - Matches
                            GET /users
                            GET /users/42
    3. First-match wins
        - Express executes the first route or middleware whose method + path match the request
        e.g :   app.use("/users", usersRouter);
                app.get("/users/:id" , handler)

                - GET /users/1
                - /users middleware runs first
                -  Router handles the request
                - /users/:id never reached
                This is called route shadowing
            NOTE : middleware can call next() and allow continuation
    4. How app.use() can shadow routes
        - Route shadowing happens when a middleware or router defined earlier matches a request and it doesn't go to next handler
        - app.use(path, middleware)
            - Matches all HTTP methods
            - Matches prefixes, not exact path

            e.g : app.use("/users",middleware)
                    -Matched
                    - GET /users
                    - POST /users
                    - GET /users/42
                    - DELETE /users/42

                - classic shadowing
                    app.use("/users" , usersRouter);
                    app.get("/users/me" , (req , res) => {
                        res.send("Current user");
                    })

                    - /users/me never reaches as use() matches the prefix
                    - Route is shadowed
                - CORRECT USAGE 
                    - user.route.js
                        router.get("/me" , handler);
                        router.get("/:id" , handler);
                    - app.js
                        app.use("/users" , usersRouter);

--------------------------------------------------------------------------------
8.Request–response lifecycle

    1.Incoming request (entry point)
        - HTTP Request : A stream of bytes sent over TCP that follow the HTTP protocol.
        - IncomingMessage (req) : Created by Node.js when it parses the HTTP request
        - ServerResponse (res) : Also Created by Node.js, used to write headers/body back to the client
        - Express entry point : A function(app) that node call with (req , res)
        - What happens before Express(Node side)
            1. TCP connection requested
            2. Raw bytes received
            3. Node's HTTP parser :
                - reads start line (GET /path HTTP/1.1)
                - parses header
            4. Node creates:
                - req - http.IncomingMessage - readable stream
                - res - http.ServerResponse - writable stream
            5. Node emits a request event
        - Where Express enters (exact hand-off)
            - When you write  
                const app = express();
                http.createServer(app).listen(3000);

                server.on("request",(req,res) => {
                    app(req , res) // this is where integration happen between Node and express
                })
        - At the moment Express receive them
            - req is a readable stream
            - res is a writable stream
            - No body has been parsed
            - No params exist
            - No middleware run
                e.g :   req.method -> "GET"
                        req.url -> "/users/43?active=true"
                        req.headers -> parsed headers
                        req.body -> undefined
            - Express is intentionally lazy (only headers are parsed)
                - Parsing body is expensive
                - Not every request need request body
                - middleware decides what to parse
                    - That's why
                        - express.json() exists
                        - express.urlencoded() exists
                        - Body parsing is opt-in
        - NODE CREATES REQ/RES, EXPRESS CONSUME THEM. 
    2. Middleware execution
        - A Middleware is a function that has access to req, res and next.
            - (req, res, next) => {}
        - A Middleware execution is sequential traversal of middleware stack until response is sent back or the stack ends
        - Middleware execution order is strictly order of registration
        - When Node call app -> app(req, res);
            - app.handle(req, res); -> app function called
            - inside app.handle, Express does
                - router.handle(req ,res ,fileHandler) - This is where middleware execution begins (router called)
        - next() means : I'm done with my work, Please go to next matching layer.
        - Middleware execution + routers
            - app.use("/user" , apiRouter)

                    app.stack
                        ↓
                    router layer
                        ↓
                    router stack
                
                - Layer - stack[Layer , Layer] 
                - stack[0] -> Layer - stack[Layer] .......nested depends upon routes

            - Router middleware run only after its mount path matches
    3. Route handler Execution
        - A route handler is a function that handles a HTTP request for a specific method and path 
        - Node -> app(req, res) -> app.router.handle() -> Layer match ? -> Router match ? -> Router handle executes
            - Router handler reaches only after all matching middlewares called next()
            - Express find the first matching middleware layer
        - middleware  -> (req, res, next) => {}
        - router handler -> (req , res) => {}
        - app.get("/users/:id" ,(req , res) => {
                console.log(req.params.id);
                res.json({id : req.param.id});
          })
            - Express extracts params (req.param = { id : "data" })
            - Route handler function called
            - Route handler write headers/body
            - Route handler end the response with res.json()
            - Express stop the lifecycle

                    app.stack
                        ↓
                    router layer
                        ↓
                    router stack
                        ↓
                    router handler

        - res.send() / res.json() / res.end() -> will end the lifecycle of request.
        - MIDDLEWARE --> PIPELINE & ROUTER HANDLER - DESTINATION 
    4. Response sent (ending the lifecycle) 
        - The request-response life cycle end's where underlying ServerResponse stream is closed.
        - Lifecycle ends when res.end() is called.
        - res.json() and res.send() eventually calls res.send()
            - res.send()
                - Set headers (if not already set)
                - writes response body
                - calls res.end() - the lifecycle is ended.
        - Different ways to end the response
            - res.send("hello")
                - Sends String/Buffer/Object
                - Sets Content-Type
                - Ends response 
            - res.json({id : 42})
                - Convert Object to String
                - Sets Content-Type : application/json
                - Ends response
            - res.end()
                - low level node api
                - Sends raw bytes
                - Ends response immediately
        - Partial responses (advanced)
            - res.write("hello"); // request still alive
            - res.write("world");
            - res.end()

--------------------------------------------------------------------------------
9. next() behavior
    - next() tells Express to continue iterating the middleware stack
    - Internally
        - Express keep a pointer(index) to router.stack
        - Calling next(), increment that pointer
        - Express decides which layer should run next
        - Conceptual code
            function next() {
                index++;
                runNextMatchedLayer();
            }
    - When to use next()
        - Logging middleware
        - Auth checks (if possible)
        - validation middleware
        - Any middleware that does not end the response    
    - If next() is not called in middleware, it wait forever over there, it will not process further, end'sup client receives connection timeout 
    - next(err) - error mode
        - switched Express into error-handling mode
        - stops normal middleware execution
        - skip request handling
        - search for (err, req, res, next) - error-handling middleware
        - Error middleware must have 4 arguments
--------------------------------------------------------------------------------
10. Short-circuiting
    - It means intentionally stopping the request-response lifecycle before it reaches to the route handler.
    - This is essential for 
        - Authorization
        - Authentication
        - Validation
        - Rate Limiting
        - Feature flags
    - next() -> to continue & res.send() -> to stop

        -   function guard(req, res, next) {
                if(!req.header.authorization) {
                    return res.status(401).send("Missing token"); -> Stop (short-circuit)
                }
                next(); -> continue
            }

                    Layer : guard
                        ↓  token missing
                    res.send("Missing token");
                        ↓
                    res.end(); end ServerResponse stream
                        ↓
                    LifeCycle ends

        -   function auth(req, res, next) {
                const token = req.headers.authorization;
                if(!token) {
                     return res.status(401).send("unauthorized"); -> Stop (short-circuit)
                } 
                //return keyword is required to return from function, if missed end up processing next middleware.
                
                req.user = decodeToken(token);
                next();
            } 
                
        -   app.use(rateLimiter);
            app.use(auth);
            app.use(validateInput);
            app.post("/users" , handler);

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------