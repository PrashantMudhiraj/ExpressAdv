1. REST principles (practical)

    - INTRO
        - REST is a set of architectural constraints(non-negotiable boundaries) that leverages(to build upon) HTTP's existing semantics(which are already existing such as methods)
        - REST -> REpresentational State Transfer (architectural style)
        - REST introduced to answer below one question :
            - How do we design APIs that keeps working when it grows and changes?
        - REST is not about any framework
        - REST is about rules that make APIs scalable and predictable
        - REST uses HTTP properly
            - URLs
            - Methods (GET, POST, etc..)
            - Status Code
            - Headers
            - REST say's don't fight with HTTP, Use it as it is designed.
        - URI - Uniform Resource Identifier
        - URL - Uniform Resource Location

    1. Resource-oriented design
        - What does "resource" mean?
            - In Rest, the focus is on "Resource" rather than "action"
            - Resource is a thing, It is not a function/button/action. 
                - Examples of things are Order, Customer, Payment. (resource)
                - Examples of Not things(function/button/action) are createOrder/cancelOrder/shipOrder
                - REST hates action based URL's (Remote Procedure Call - RPC style routing) 
                    - POST /createOrder
                    - POST /cancelOrder
                    - The URL describes what you want to do(createOrder , cancelOrder), not what you are working with (order, payment, customer)
                - URL's should point to things, not actions.
                    - "what action am i performing?"
                    - "what thing am i working with?"
                        - /orders -> all orders
                        - /orders/123 -> one specific order
                    - HTTP methods are taking care of actions
                        - GET  -> give me data
                        - POST -> create something new
                        - PATCH -> update existing data
                        - DELETE -> remove something
                - So,
                    - POST /orders -> create order
                    - GET /orders/1 -> get order
                    - PATCH /orders/1 -> change order

    2. Stateless
        - Stateless means,"The Server does not remember you from previous request"
        - For every request must include:
            1. Who you are(token)
            2. What resource you want(URL)
            3. What you want to do(HTTP method)
            4. Any required data(body/query)
                GET /orders/123
                Authorization: Bearer <token>
        - The server : 
            - Reads token
            - Check permissions
            - Fetch order
            - Sends response
            - Forgets everything
        - Why this fails in production (state full):
            - Production Express apps run in multiple instances (using PM2 clusters or Kubernetes pods). If Request 1 goes to Instance A and Request 2 goes to Instance B, Instance B has no idea about the state stored in Instance A. The client’s experience becomes inconsistent and buggy

    3. Client-server separation
        - Client and Server have different jobs
            - Client(frontend, mobile app): The Client owns the UI and the user experience
                - Decide user flow
                - Handles screen and buttons
            - Server : The server owns the data and business logic
                - Stores data
                - Applies rules
                - Return results
        - The Server doesn't care about UI flows

        - What is the thing ? -> resource
        - What do i want to do to it ? -> HTTP method
        - What changed ? -> representation(JSON)
        - REST is "changing the state of things using HTTP rules"
------------------------------------------------------------------------------------------------
2. Resource naming & URL design 

    1. Nouns vs verbs
        - URLs name things.
        - HTTP methods describe action
        - If the URL contains a verb, it's usually wrong (verb based URLs)
            - This is bad because URLs describe actions
            - HTTP methods becomes meaningless
            - Everything turns into POST
            - API become hard to reason about
                - /createOrder
                - /getOrders
                - /cancelOrder
                - /updateOrderStatus 
        - Good (noun based URLs)
            - /orders
            - /orders/123
            - Now actions are expressed by HTTP methods
                Action          Method      URL
                ------------    ------      -----------
                Create order    POST        /orders
                Get order       GET         /orders/123
                update order    PATCH       /orders/123
                Delete order    DELETE      /orders/123
            - URL stay stable, method changes the behavior

    2. Pluralization
        - Why /orders is plural
        - In Rest, a URL can represent:
            - A collection of resources
            - A single member of that collection
            - GET /orders - Returns a collection of orders.
            - GET /orders/:id - Returns a specific instance from a collection.
        - using pluralization consistently prevents ambiguity. If you use /order, does is refer a collection or a single order ?
        - using /orders clearly identifies a collection.

    3. Nested resources
        - URLs should reflects relationship between resources. If a resource belongs to another, The URI structure should show that hierarchy.
        - Resource does not make sense without parent.
        - orderItem cannot exit without an order.
            - /orders/123/items -> single order with multiple order items
            - /orders/123/items/456 -> single order with single order item.
        - Internal Execution (The "mergeParams" constraint) ;
            - When you see Nested parameters, The Child router's does have access to parent req.params by default. T
            - This is an internal design choice to keep routers isolated. 
            - To access parent req.params, we should manually enable it.
                - e.g:

                    const orderRouter = express.Router();
                    const orderItemRouter = express.Router({ mergeParams :  true });

                    orderRouter.use("/:orderId/Items", orderItemRouter);

                    orderItemRouter("/:orderItemId" , (req , res) => {
                        const { orderId, orderItemId } = req.params;

                        res.json({ orderId, orderItemId })
                    })
        
    4. Avoid deep nesting
        - maximum hierarchy we should consider is 2(levels)
        - to avoid complexity (authorization)
        - For scalability
        - tight coupling
        - Industry rule of thumb
            - "At most one level of nesting beyond the root resource"
        
        Drawbacks:
            1. Regex Complexity : Internally, Express converts these paths into complex regular expression. Longer path is directly increasing the loaf/work on path-to-regex.
            2. Client burden : for every request client needs to send different Id's
            3. Database coupling : Your API structure becomes strictly tied to your database schema hierarchy.
------------------------------------------------------------------------------------------------
3. HTTP methods

    - In RESTful API design, HTTP methods(often called verb) define the action to be performed on the resource identified by the URI.

        1. GET method:
            - I want current representation of this resource. I am not changing anything.
            - Correct usage :
                - GET /orders/123
                - Fetch order 123

                    app.get("/order/:id", async (req, res) => {
                        const { id } = req.params;
                        const order = await orderService.getById(id);

                        if(!order) {
                            return res.status(404).json({ message : "order not found"})
                        }

                        res.json(order);
                    })

            - Key Properties :
                - No mutation
                - No counters
                - No logging that affects business state

        2. POST method:
            - Please create a new subordinate resource under this collection
            - It is used to create a new entity to the specified resource, often resulting in a change in state or side effects on the server
            - * POST is not idempotent *
            - * calling it twice may create two resources (duplicates)*
            - e.g :
                - POST /orders
                
                    app.post("/orders', express.json(), (req, res) => {
                        /* IMPORTANT : before creating resource we must sanitize(validations) the request. */
                        const order = await orderService.create(req.body);
                        res.status(201).json(order);
                    })

        3. PUT method:
            - Replace the entire state of the resource with what I'm sending
            - It is not a partial update it is Complete replacement of resource by request body
            - PUT is dangerous
                - Missing fields amy be overwritten or removed
                - Accidental data loss in common.
            - PUT is idempotent, because  if you send the exact same request 10 times, the state of the server is same as after the first request
            - PUT /orders/123
                {
                    status : "shipped"
                }
                - data loss like orderId, shipping details etc..

        4. PATCH method:
            - Partial update, Apply these changes on the existing resource
            - It does not replace everything
            - e.g:
                - PATCH /orders/123

                    app.patch("/orders/:id", express.json() , async(req, res, next) => {
                        const { id } = req.params;
                        const data =  req.body;
                        const updated = await orderService.update( id, data);

                        res.json(updated);
                    })
            - Typical use cases :
                - update shipping status
                - update shipping address
                - cancel an order
            - Safer than PUT, as it is partial update

        5. DELETE method:
            - Remove this resource
            - Data is often soft-deleted
            - Resource may be marked as inactive
            - e.g:
                - DELETE /orders/123

                    app.delete("/orders/:id" , async (req, res) => {
                        const { id } = req.params;

                        await orderService.delete(id);

                        res.status(204).end(); 
                    })
                - Why 204 No content:
                    - Resource is gone
                    - No response body needed
        
        6. OPTIONS method:
            - What is allowed to be done with this resource ?
            - An OPTIONS request asks the server :
                - For this URL, which HTTP methods, headers and behaviors are supported ?
                - e.g :
                    - OPTIONS /orders/123
                    - The server will respond with capabilities, not data
            - This is essential for :
                - CORS
                - API gateways
                - Security enforcement
                - Client tooling
            - OPTIONS and CORS (Most Common Real-World Use)
                - The real problem browsers have
                - * Browsers enforces Same-Origin Policy *:
                    - Javascript cannot freely call API's of other domain
                    - This is security rule, not a backend choice.
            - What triggers a CORS preflight ?
                - A browser sends a OPTIONS when:
                    - Method is not GET/POST
                    - OR custom headers are used
                    - OR content-type is not simple (application/json often triggers it)
                    - e.g :
                        - PATCH /orders/123
                        - Authorization: Bearer <token>
                        - Content-type : application json
                    - Browser behavior:
                        1. Sends OPTIONS first
                        2. Ask permissions
                        3. Only then send PATCH
                    - Preflight OPTIONS request
                        - OPTIONS /orders/123
                        - Origin: https://frontend.example.com
                        - Access-Control-Request-Method: PATCH
                        - Access-Control-Request-Headers: Authorization, Content-Type
                    - Expected Response
                        - HTTP/1.1 204 No Content
                        - Access-Control-Allow-Origin: https://frontend.example.com
                        - Access-Control-Allow-Methods: GET, PATCH, DELETE  //yes, you are allowed to do this
                        - Access-Control-Allow-Headers: Authorization, Content-Type
            - OPTIONS is about permissions, Not Data
            - e.g :
                        app.get("/orders/:id",() => {})
                        app.patch("/orders/:id",() => {})
                        app.delete("/orders/:id",() => {})
                - This route support GET, PATCH, DELETE, So an OPTIONS request returns:
                    - Access-Control-Allow-Methods : GET, PATCH, DELETE
            - When you Must Handle OPTIONS explicitly
                1. You implements customs CORS logic
                2. You block or allow methods dynamically
                3. You sit behind strict API gateway

                - e.g:  
                        app.options("/orders/:id" , (req, res)) => {
                            res.set({
                                Access-Control-Allow-Methods: 'GET, PATCH, DELETE',
                                Access-Control-Allow-Headers: 'Authorization, Content-Type'
                            })

                            res.sendStatus(204);
                        }
------------------------------------------------------------------------------------------------
4. Safe vs Idempotent HTTP Methods
    - In distributed systems, requests WILL be retried.
    - In distributed systems, network failures are inevitable. A client might send a request, the server might process it successfully, but the network might drop the response before it reaches the client. This is where the concepts of Safety and Idempotency become critical for building resilient backends.
    - safe and Idempotent semantics are exist so retries don't corrupt data.
    - Scenario
        - Network drops after server processes the request(not sent back to client)
        - Load balancer times out
        - Client crashes mid-request
        - reverse proxy retires
        - Mobiles network resend request
        - What happens if same request is executed again ?
            - safe and idempotent methods are the answer to this question

    1. Safe Methods
        - A method is called as safe, when execution does not effect the server state. no matter how many times it is called.
        - Safety is about side effects, not logic
        - Methods : GET, HEAD, OPTIONS
            - GET is the primary safe method
                - GET /orders/123
                - No database writes
                - No counter incremented
                - No state transitions
                - No 'last accessed flag"
                
                - We are allowed to
                    - Read data from DB
                    - compute derived data
                    - Log access
    
    2. Idempotent Methods - Same Result, Every Time
        - A method is Idempotent if the side effects of making request multiple times is same as making it exactly one
        - mathematically: f(x) = f(f(x))
            - Idempotent !== Safe
            - Idempotent can change the state.
        - All Safe methods are idempotent, Not all idempotent are safe methods
        - Idempotent methods: GET, HEAD, PUT, DELETE, OPTIONS
            - GET -> getting data from server
            - PUT -> replace the existing resource
            - DELETE -> intent is to delete the resource (first request-> 204, second request-> 404)
            - OPTIONS -> does not affect the state 
        - Non-Idempotent methods: POST
            - POST will create duplicate resource again and again.
        - The Tricky case : PATCH is generally not guaranteed to be idempotent
            - PATCH applies changes, not replacements
            - If PATCH sets state explicitly
                - It may be idempotent
            - But consider:
                - PATCH /orders/123
                    {
                        amount : "+100";
                    }
                - Amount increases for every request(risky)
        - *Important*
            - GET -> Must be side-effect free
            - DELETE -> Must be safe to retry
            - POST -> Must assume retires will happen and Must be protected when money or inventory is involved
            - PATCH -> Must be explicit about state transition
------------------------------------------------------------------------------------------------
5. Proper HTTP status codes
    - Status codes are not decorations. There are primary signals to the distributed systems
    - The HTTP status code is the primary metadata the server provides to the client. It allows client to decide the next move
    - In Production, many actors consume your API;
        - Browser
        - Mobile Apps
        - Load balancers
        - API gateways
        - Retry mechanism
        - Monitoring tools
        - Alerting systems
    - Most of them, do not prase the response body(JSON), Only look for status code
    - So, the Status code is your API's truth signal

    - Codes
        - 200 vs 201 “Success” Is Not One Thing
            - 200 -> "The request succeeded"
                - Use 200 when
                    - You successfully retrieved the data
                    - You successfully updated the data
                    - The resource already exist
                        - GET /orders/123 -> 200 OK
                        - PATCH /orders/123 -> 200 OK
            - 201 -> "A new resource now exists"
                - Use 201 when
                    - A new resource is created
                    - The Server generated the resource identity
                        - POST /orders/123 -> 201 created
                        - e.g:
                                app.post("/order" , async(req, res) => {
                                    const order =  await orderService.create(req.body);
                                    res.status(201).json(order);
                                })
                    - If we do not mention status code, By default Node send 200 code. -> res.json(order)

        - 204 No Content - "Success, but nothing return"
            - The request succeeded, and there is no response body.
                - Use 204 when
                    - DELETE operations
                    - Some idempotent updates
                    - DELETE /orders/123 -> 204 No Content
                    - e.g:  
                            app.delete("/orders/123",async (req , res) => {
                                await orderService.remove(req.params.id);
                                res.status(204).end(); // do not use send -> send will check content-type etc.. which is not required
                            })

        - 400 vs 422 Syntax vs Semantics
            - 400 Bad Request -> "I cannot parse this request"
                - Use 400 when:
                    - JSON is malformed
                    - Required fields are missing in the request
                    - Request format is in correct.
                        - POST /orders
                            { invalid JSON } -> 400 Bad Request
            - 422 Unprocessable Entity - "Request is valid, but wrong"
                - Use 422 when:
                    - JSON is valid
                    - But values violates the business rules
                        - POST /orders
                            {
                                quantity : -5
                            }
                            -> 422 Unprocessable Entity
            - Fix 400 by correcting format
            - Fix 422 by correcting data

        - 401 vs 403 Authentication vs Authorization
            - 401 Unauthorized - "Who are you?"
                - Use 401 when:
                    - Missing token
                    - Invalid token
                    - Expires token
                        - GET /orders/123
                            { no Authorization header }
                            -> 401 Unauthorized
            - 403 Forbidden - "I know who you are(authenticated), but not allowed"
                - Use 403 when:
                    - Scope/roles missing
                        - GET /orders/123
                            (user does not own this resource)
                            -> 403 Forbidden

        - 404 vs 409 - Absence vs Conflict
            - 404 Not Found — “Resource does not exist”
                - Use 404 when;    
                    - The resource Id does not exist
                    - The URL is valid, but the resource isn't
                        - GET /orders/999
                            -> 404 Not Found
            - 409 Conflict - "State Conflict"
                - Use 409 when:
                    - The request conflict with the current state
                        - PATCH /orders/123
                            {
                                status : "shipped"
                            } 
                        - But the order is cancelled
                        - 409 Conflict
                - Mostly use it for business logic

        - 500 vs 503 - Your Fault(server) vs Temporary Failure
            - 500 Internal server error - "Bug"
                - Use 500 when
                    - unhandled exception
                    - Programming error
                    - Inconsistent state
                    - This means server is broken.
            - 503 service unavailable - "Try again later"
                - Use 503 when:
                    - Database is down
                    - Dependency is unavailable
                    - System is overloaded
                - 503 signals
                    - Temporary failure
                    - Retry must succeed
                - This is critical for :
                    - Retry logic
                    - Circuit breakers
                    - Auto Scaling
        - Status Codes Drive Client Behavior
            if(res.status >= 500) retry();
            if(res.status === 401) redirectToLogin();
            if(res.status === 422) showValidationErrors();

        - 3XX status codes - Redirection and Control Flow
            - The resource you want is somewhere else, or should be accessed differently
            - 301 Moved Permanently
                - This resource has a new permanent URL
                    - Response includes:   
                        Location /new-url
            - 302 Found (Temporary redirect)
                - This resource is temporarily available elsewhere
------------------------------------------------------------------------------------------------
6. Idempotent Keys
    - Idempotent key turn a Non-Idempotent operation into a retry-safe operation in application level.
    - Real production scenario
        - POST /orders
            1. Client sends request
            2. Server create order
            3. Server responds with 201 Created
            4. Response is lost(timeout/network issue)
            5. Client retries
        - Result
            - Two orders created
            - Same intent
            - Different IDs
    - A client generated unique identifier that represents one logical operation, regardless of how many times it is sent.
    - Client Behavior
        - Before sending a POST request
            1. Generate a unique key(UUID)
            2. Sends it in a header
                - POST /orders
                - Idempotent-key : <unique key>
    - Server behavior(high-level)
        - When the server receives a POST request with an idempotent key:
            1. Look up the key in a persistent store(redis)
            2. if does not exist:
                - Process the request
                - store the result (status + response body)
                - Associate with the key
            3. if key already exist:
                - Do not re-execute logic
                - Return the stored response
    - Where idempotency is Mandatory(Real world)
        - Payments
        - Order Creation
        - Inventory reservation
        - Email sending
        - Any side-effect-heavy POST
    - Rules
        1. key is required for POST request
        2. Same key + same user -> same result
        3. Same key + different payload -> error (important)
        - why rule #3 is important
            - Prevent accidental misuse
            - Forces correctness on the client
------------------------------------------------------------------------------------------------
7. API response structure
    - In Production environment, Consistency it the most important attribute for an API' response structure. Client can able to write single piece of code for "success" and single piece of code for "failure"
    - Client do not integrate with your code or database, they rely on response from server

    1. Consistent success response
        - Clients can predict where to find the actual data regardless of the endpoint
        - Two common patterns
            1. Bare/Flat Response(No Envelope)
                {
                    "id" : 123,
                    "status" : "created",
                    "total" : 500
                }
                - Pros
                    - simple
                    - less nesting
                    - easy for small APIs
                - Cons
                    - no place for metadata
                    - Hard to add pagination info
                    - Hard to add requester identifier
            2. Envelope Response
                {
                    "data" : {
                        "id" : 123,
                        "status" : "created",
                        "total" : 500
                    },
                    "<meta-info" : {
                        ....
                    }
                }
                - Pros
                    - Clear separation of data and metadata
                    - Easy to extend without breaking clients
                    - Consistent parsing logic
                    - Scales well with pagination, link, etc...
        - Standard success response shape
            - Canonical success format
                {
                    "data" : <RESOURCE | ARRAY>,
                    "meta" : {....} // optional
                }

                - data is always present in success response
                - meta is optional and non breaking
                - No success : true flag
            - e.g : 
                - POST /orders
                    -> 201 Created

                        {
                            "data" : {
                                "id" : 123,
                                "status" :; "created",
                                "total" : 500,
                                "customerId" : 10
                            } //RESOURCE
                        }

                - Always read response data
                - Never inspect endpoint for response (response remain consistent for API's)
                - GET /orders
                    -> 200 OK
                
                        {
                            "data" : [
                                { "id" : 123, "status" : "created" },
                                { "id" : 124, "status" : "paid" }
                            ]
                            "meta: {
                                "page" : 1,
                                "limit" : 20,
                                "total" : 124
                            }
                        }
    2. Consistent error responses
        - Canonical error response
            {
                "error" : {
                    "code" : "ORDER_NOT_FOUND",
                    "message" : "Order not found"
                }
            }
        - Rules
            - error is always present on failure response
            - code is machine-readable
            - message is human-readable
        - e.g : 
                app.get("/orders/:id" , async(req, res) => {
                    const order = await orderService.getById(req.params.id);

                    if(!order) {
                        return res.status(404).json({
                            "error" : {
                                "code" : "ORDER_NOT_FOUND",
                                "message" : "Order not found"
                            }
                        })
                    }

                    res.status(200).json({ "data" : order })
                })
------------------------------------------------------------------------------------------------
8. Error response standardization

    1. Why Error Standardization is mandatory(Not optional)
        - In productions:
            - Frontend teams write conditional logic
            - Mobile apps need localized message
            - SDKs need machine-readable signals
            - Retry logic need to know what failed
            - Observability needs clarification
        - If errors are inconsistent
            - Client parse string
            - Logic breaks on message change
            - Refactors cause regression
            - Debugging become guesswork
        - Standardization means every error must be in same shape and rule, regardless of error where it is coming from.
        - Canonical Error Response Shape.
            - For all error expect 204, we use:
                {
                    "error" : {
                        "code: "SOME_ERROR_CODE", // machine-readable
                        "message": "Human readable explanation of the error", // Human-readable
                        "details": {} //optional
                    }
                }
    
    2. Error Codes vs Error Messages
        - It is for machines
        - Error codes:
            - Are stable
            - Never localized (translation)
            - Never exposed from internal exceptions
            - Used by clients for logic
            - e.g:
                    "code" : "ORDER_NOT_FOUND"
                    
                    - CLIENT LOGIC

                            if(error.code === "ORDER_NOT_FOUND") {
                                showNotFoundUI();
                            }
        - Error Messages
            - Can change wording
            - Can be localized (translation)
            - Are shown to the users or developers
            - e.g: 
                    "message" : "order not found"
            - Never write client logic based on messages
        - Base API error code

                // Existing interface
                interface Error {
                    name: string;
                    message: string;
                    stack?: string;
                }
            
                class ApiError extends Error {
                    constructor({ code, message, status, details }){
                        super(message);
                        this.code = code;
                        this.status = status;
                        this.details = details;
                    }
                }
            
            - Example Not Found Error

                class NotFoundError extends ApiError {
                    constructor(code, message = 'Resource not found'){
                        super({
                            code,
                            message,
                            status : 404
                        })
                    }
                }

            - Usage:  
                - throw new NotFoundError("ORDER_NOT_FOUND", "order not found")
    
    3. Field-Level validation Errors
        - The error response should be clearly describe which field is failed validation and why, in a machine readable structure
        - The Problem they solve
            - POST /orders
                {
                    "quantity" : -1,
                    "price" : "abc",
                    "customerId" : null
                }
            - If API returns
                {
                    "error" : {
                        "code" : "VALIDATION_ERROR",
                        "message" : "Invalid request"
                    }
                }
                - In this client has no idea
                    - Which field is wrong
                    - What exactly is wrong
                    - How to show inline errors in UI
            - Correct error response
                {
                    "error" : {
                        "code" : "VALIDATION_ERROR"
                        "message": "Request validation failed",
                        "details" : {
                            "fields" : {
                                "quantity" : "Must be greater than 0",
                                "price" : "Must be a number",
                                "customerId" : "Required"
                            }
                        }
                    }
                }

                - client logic can be simple
                    -   if(err.code === "VALIDATION_ERROR") {
                            showInlineErrors(error.details.fields);
                        }

    4. Avoid leaking internals
        - Leaking internals happens when your API exposes:
            - Stack error
            - SQL errors
            - File paths
            - Library-specific messages
            - Environmental details
        - example of bad response:
            {
                "error: {
                    "message": "cannot read property 'id' of undefined",
                    "stack": "TypeError at orderService.js:42"
                }
            }
            - This tells an attacker:  
                - Language (Node.js)
                - File structure
                - Code paths
                - Possible attack vectors
        - Client should know what went wrong, but never how it was implemented
        - Correct handling of internal errors
            - throw new Error("Database connection refused");
            - The Client should receive:
                {
                    "error: {
                        "code": "INTERNAL_SERVER_ERROR",
                        "message": "Something went wrong"
                    }
                }
            - Meanwhile, internally, you log the real error:
                - logger.error(err);
------------------------------------------------------------------------------------------------
9. Pagination strategies

    - In production, you must never allow an endpoint to return an unbounded number of resources. If a table has a million rows and a user hit GET /products, you express tries to serialize a large JSON array, Which may leads to exhausting Node.js heap memory
    - Pagination is the mechanism of returning data in discrete "chunks"
    - It is a data-access and performance control mechanism
    - If pagination is designed poorly:
        - Data slow down
        - Response become inconsistent
        - Clients see duplicates or missing data
        - Large datasets become unusable
    - In real systems
        - Orders can be in millions
        - Returning "all data" is impossible
        - Memory, CPU, network becomes bottlenecks
    - So, Pagination solves this problem, but should be handled carefully

    - Two Real Pagination strategies
        - There are only two serious approaches in productions systems:
        1. Offset-based pagination
            - Client specific:
                - How many records to skip
                - How many records to take
                - GET /orders?page=3&limit=20 -> OFFSET 40 LIMIT 20 -> offset = (page - 1) * limit = (3 - 1) * 20 = 40
                - GET /orders?offset=40&limit=20 -> OFFSET 40 LIMIT 20
                - Typical API response

                    {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "page" : 3,
                            "limit" : 20,
                            "total" : 142
                        }
                    }

                - Performance issue
                    - Scan and discard OFFSET rows
                    - Cost increases with page number
                    - Large offsets = slow query
                - Offset-based pagination is okay when:
                    - Dataset is small
                    - Data changes rarely
                    - UI requires page numbers
                    - Performance is not critical
        2. Cursor-based pagination
            - Instead of page numbers, the client uses a cursor.
                - A pointer to the last seen record
                - Usually based on a stable, indexed column
                - GET /orders?limit=20&cursor=2026-01-16T10:15:05Z
                    - "Give me the next 20 records after this cursor"

                   {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "nextCursor" : 2026-01-16T11:15:05Z,
                            "limit" : 20,
                        }
                    }

                - No page numbers, Just give me the next chuck.
            - Why cursor pagination is superior
                - Cursor pagination:    
                    - Is stable under concurrent inserts
                    - Avoids OFFSET scan
                    - Scales to millions rows
                    - Matches streaming behavior
            - Choosing a Cursor
                - A cursor must be:
                    - stable
                    - indexed
                    - Monotonic (always increasing or decreasing)
                - Good Cursor fields:
                    - createAt
                    - Auto-increment id
                    - Composite (createAt, id)
                - Bad Cursor fields:
                    - Random UUID
                    - Mutable fields
                    - Non-indexed column

            - Cursor Pagination example
                - Request
                    - GET /order?limit=20&cursor=1701418200000
                - Server logic
                    - SELECT * FROM orders WHERE created_at > cursor ORDER BY created_at ASC LIMIT 20;
                - Response
                    {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "nextCursor" : 1701418600000,
                            "limit" : 20,
                        }
                    }


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
