1. Express as a function over http.createServer

    - Node provide the HTTP module
    - It can create an HTTP server
    - It listen to the port
    - It receives request and send response
    - NODE JS IS THE ACTUAL SERVER
    
    - Express is a web framework
    - It is build on top of Node's HTTP module
    - provides routing and middleware
    - But internally
        - Express returns a function
    - Express does
        - Receives req and res
        - Starts its middleware and routing logic
    - Express is simply a function passed into Node's server
    - Node calls Express(as a function)
    - NODE IS THE SERVER, EXPRESS IS THE REQUEST HANDLER
--------------------------------------------------------------------------------
2. Why does node need express

    - node alone
        if (req. meth od === "GET" && req. url  === "/users") {
            ......
        };
    - Express
        app.get("/users" , handler);
    - So Express adds: 
        - Routing abstraction
        - Middleware chain
        - Cleaner code
        - Reusability
--------------------------------------------------------------------------------
3. Express is not a server, Node is

    - What does a server actually means ?
        - A server is something that can
            1. Open a Network port(e.g,. 3000)
            2. Accept a TCP connections
            3. Read raw bytes from the network
            4. Prase protocols (like HTTP)
            5. Send bytes back to the client
        - Node.js provides
            1. TCP sockets (via net module)
            2. HTTP parsing (via http module)
            3. Event loop
            4. OS level async I/O
        - Express does only
            1. Routing (app.get , app.post)
            2. Middleware chaining
            3. Request/Response helpers
--------------------------------------------------------------------------------
4. Express architecture

    1. app (const app = express())
        - app is both a function(Node can call it) and an Object(methods and properties attached)
        - app is instance of a function
        - app.use is typeof function
            eg : function createServer() {
                    function app(req, res, next){
                        app.handle(req, res, next) // handle can be any http method
                    } //function
                    app.use = function use(){} //app treated as object, bounded with methods
                    app.get = function get(){}
                }
        - properties and methods are attached to the functions.
        - In Javascript functions are objects.
        - Internally app holds
            - app._router -> main router
            - app.settings -> configuration (evn, trust proxy)
            - app.locals -> app-level shared variables
    2. router Object
        - express.Router() is mini Express app that can :
            - register routes
            - register middlewares 
            - be mounted on the main app
        - It is introduced for
            - Group related routes
            - Isolate logics
            - Build modular, scalable API's
        - type of router is a function
        - Router is a child of app
        - Express treats Router() as a middleware, For matching paths, forward the requests to the router. Router then run its own stack
        - route flow : 
                GET /api/users
                    ↓
                app middleware
                    ↓
                router middleware
                    ↓
                router route handler
    3. middleware stack
        - An Ordered list (array) of middleware layers that Express executes sequentially for a request
        - The middleware stack is core execution model of Express.
        - Its job it to :
            - inspect or modify req
            - inspect or modify res
            - Decide whether to pass control forward
            e.g.
                app.use(logger)
                app.use(auth)
                app.get("/users",handler);

                - Express build something like this (middleware stack)
                    [
                        loggerMiddleware,
                        authMiddleware,
                        usersRouterMiddleware
                    ]
        - Execution model
            1. Express start a index 0 of the stack
            2. Executes the first middleware
            3. That middleware must call next()
            4. Express moves to next middleware
            5. This will continue till: 
                - A response is sent OR The stack ends

                            Request
                                ↓
                            [ Middleware 1 ]
                                ↓ next()
                            [ Middleware 2 ]
                                ↓ next()
                            [ Route Handler ]
                                ↓ res.send()
                            Response
--------------------------------------------------------------------------------
5. app vs router internals

    1. express() vs express.Router()
        - app
            - app is the root express application
            - the entry point for all http requests 
            - the only object that :
                - can start a server (listen to a port)
                - can integrate with Node's http layer
        - router
            - A modular, mountable request handler
            - designed only to:
                - Group routes
                - Group middlewares

        eg : function createApp() {
                function app(req, res, next) {
                    app.handle(req, res, next)
                }
                app.router.stack = []
                app._router = new Router(); // mountable request handler
                app.listen = function listen() {}

                return app;
            }

            function Router(){
                function router(req, res, next){
                    router.handle(req, res, next)
                }

                router.stack = [];
                return router;
            }
    2. use router for feature based API's and use app for small/temporary/POC api's
    3. Modular routing : organizing routes
        - Maintainability
        - Team scalability
        - Testability
--------------------------------------------------------------------------------
6. Router mounting basics

    1. app.use("/api" , router)
        - Router mounting : It means attaching a router as a middleware at a specific path prefix.
        - Here, For any request starting with /api, pass control to the router. 
        - when you mount a router
            - (req, res, next) => router.handle(req, res, next)
            - So router becomes one middleware layer inside the app's middleware stack
            - eg : -> Path : /api/user/active/:id
                    app -> /api -> routeHandler (/user/active/:id)
                    routeHandler -> /user -> activeRequestHandler (/active/:id)
                    activeRequestHandler -> /active/:id -> service logic and returns the response.
    2. req.url vs req.baseUrl
        - req.url 
            - The current URL path that Express is processing (after prefix stripping by mounted routers)
            - changes as request moves through router
            - Relative to the current router
        - req.baseUrl
            - The mount path on which the current router was mounted
            - set by Express during router mounting
            - Does not change inside the router
                -> GET /api/users/:id
                    {
                        "/api" : {
                            "/users" : { 
                                "/" : fn(){},
                                "/:id" : fn(){}
                            } 
                        }
                    }
                -> /api is baseUrl for /users (url)
                -> /api/users is baseUrl for / and /:id (url)
                -> GET /api/users
                -> url: /users and baseUrl: /api
        - req.originalUrl 
            - The complete path
        eg :  
            -> GET /api/orders/1
            app.use("/api", apiRouter);
            app.use("/orders" , ordersRouter);
            api.get("/:id" , () => {});

            orderRouter req.url -> /1 -> remaining path of router
            orderRouter req.BaseUrl -> /api/orders -> where the router is mounted
            orderRouter req.originalUrl -> /api/orders/1 -> complete url

        - req.originalUrl === req.baseUrl + req.url
        - req.originalUrl is the untouched original path, while req.baseUrl + req.url explain how Express got there.
--------------------------------------------------------------------------------
7. Route matching & execution order

    1. HTTP method matching
        - Express executes a router handler only if the HTTP method matches with route's declared method
            e.g : app.get("/users" , routeHandler)
                  app.post("/users" , routerHandler)
        - HTTP method comes from Node.js (req.method), Node parses it from HTTP request.
        - app.use() does not care about HTTP methods, It matches all methods, Generally used for method-agnostic middleware
            e.g : Auth middleware often uses use()
    2. Path matching
        - The Path matching is a process by which Express compare the request URL with a registered route path to decide whether a handler should run.
        - Query String are excluded in Path Matching

        e.g :   app.get("/users" , routeHandler)
                    - Matches 
                        GET /users
                    - Does not match
                        GET /users/
                        GET /users/42

                app.get("/users/:id" , routeHandler)
                    - Matches 
                        GET /users/42
                        GET /users/abc
                    - req.param = { id : 42 }
                    - Does not match
                        GET /users
                        GET /users/42/profile    
                
                app.get("/users/:userId/orders/:orderId, handler)
                    - Matches
                        GET /users/10/orders/1
                        - req.params = { userId : 10, orderId : 1 }

                - WildCard match (*)
                    app.get("/files/*", handler) 
                        - Matches
                            GET /files/a.txt
                            GET /files/images/logo.png
                        - Matches anything after that point

                - Optional parameter
                    app.get("/users/:id?",handler)
                        - Matches
                            GET /users
                            GET /users/42
    3. First-match wins
        - Express executes the first route or middleware whose method + path match the request
        e.g :   app.use("/users", usersRouter); // use checks only prefix
                app.get("/users/:id" , handler)

                - GET /users/1
                - /users middleware runs first
                -  Router handles the request
                - /users/:id never reached
                This is called route shadowing
            NOTE : middleware can call next() and allow continuation
    4. How app.use() can shadow routes
        - Route shadowing happens when a middleware or router defined earlier matches a request and it doesn't go to next handler
        - app.use(path, middleware)
            - Matches all HTTP methods
            - Matches prefixes, not exact path

            e.g : app.use("/users",middleware)
                    -Matched
                    - GET /users
                    - POST /users
                    - GET /users/42
                    - DELETE /users/42

                - classic shadowing
                    app.use("/users" , usersRouter);
                    app.get("/users/me" , (req , res) => {
                        res.send("Current user");
                    })

                    - /users/me never reaches as use() matches the prefix
                    - Route is shadowed
                - CORRECT USAGE 
                    - app.js
                        app.use("/users" , usersRouter);
                    - user.route.js
                        router.get("/me" , handler);
                        router.get("/:id" , handler);
--------------------------------------------------------------------------------
8. Request–response lifecycle

    1.Incoming request (entry point)
        - HTTP Request : A stream of bytes sent over TCP that follow the HTTP protocol.
        - IncomingMessage (req) : Created by Node.js when it parses the HTTP request
        - ServerResponse (res) : Also Created by Node.js, used to write headers/body back to the client
        - Express entry point : A function(app) that node call with (req , res)
        - What happens before Express(Node side)
            1. TCP connection requested
            2. Raw bytes received
            3. Node's HTTP parser :
                - reads start line (GET /path HTTP/1.1)
                - parses header
            4. Node creates:
                - req - http.IncomingMessage - readable stream
                - res - http.ServerResponse - writable stream
            5. Node emits a request event
        - Where Express enters (exact hand-off)
            - When you write  
                const app = express();
                http.createServer(app).listen(3000);

                server.on("request",(req,res) => {
                    app(req , res) // this is where integration happen between Node and express
                })
        - At the moment Express receive them
            - req is a readable stream
            - res is a writable stream
            - No body has been parsed
            - No params exist
            - No middleware run
                e.g :   req.method -> "GET"
                        req.url -> "/users/43?active=true"
                        req.headers -> parsed headers
                        req.body -> undefined
            - Express is intentionally lazy (only headers are parsed)
                - Parsing body is expensive
                - Not every request need request body
                - middleware decides what to parse
                    - That's why
                        - express.json() exists
                        - express.urlencoded() exists
                        - Body parsing is opt-in
        - NODE CREATES REQ/RES, EXPRESS CONSUME THEM. 
    2. Middleware execution
        - A Middleware is a function that has access to req, res and next.
            - (req, res, next) => {}
        - A Middleware execution is sequential traversal of middleware stack until response is sent back or the stack ends
        - Middleware execution order is strictly order of registration
        - When Node call app -> app(req, res);
            - app.handle(req, res); -> app function called
            - inside app.handle, Express does
                - router.handle(req ,res ,fileHandler) - This is where middleware execution begins (router called)
        - next() means : I'm done with my work, Please go to next matching layer.
        - Middleware execution + routers
            - app.use("/user" , apiRouter)

                    app.stack
                        ↓
                    router layer
                        ↓
                    router stack
                
                - Layer - stack[Layer , Layer] 
                - stack[0] -> Layer - stack[Layer] .......nested depends upon routes

            - Router middleware run only after its mount path matches
    3. Route handler Execution
        - A route handler is a function that handles a HTTP request for a specific method and path 
        - Node -> app(req, res) -> app.router.handle() -> Layer match ? -> Router match ? -> Router handle executes
            - Router handler reaches only after all matching middlewares called next()
            - Express find the first matching middleware layer
        - middleware  -> (req, res, next) => {}
        - router handler -> (req , res) => {}
        - app.get("/users/:id" ,(req , res) => {
                console.log(req.params.id);
                res.json({id : req.param.id});
          })
            - Express extracts params (req.param = { id : "data" })
            - Route handler function called
            - Route handler write headers/body
            - Route handler end the response with res.json()
            - Express stop the lifecycle

                    app.stack
                        ↓
                    router layer
                        ↓
                    router stack
                        ↓
                    router handler

        - res.send() / res.json() / res.end() -> will end the lifecycle of request.
        - MIDDLEWARE --> PIPELINE & ROUTER HANDLER - DESTINATION 
    4. Response sent (ending the lifecycle) 
        - The request-response life cycle end's where underlying ServerResponse stream is closed.
        - Lifecycle ends when res.end() is called.
        - res.json() and res.send() eventually calls res.end()
            - res.send()
                - Set headers (if not already set)
                - writes response body
                - calls res.end() - the lifecycle is ended.
        - Different ways to end the response
            - res.send("hello")
                - Sends String/Buffer/Object
                - Sets Content-Type
                - Ends response 
            - res.json({id : 42})
                - Convert Object to String
                - Sets Content-Type : application/json
                - Ends response
            - res.end()
                - low level node api
                - Sends raw bytes
                - Ends response immediately
        - Partial responses (advanced)
            - res.write("hello"); // request still alive
            - res.write("world");
            - res.end()
--------------------------------------------------------------------------------
9. next() behavior

    - next() tells Express to continue iterating the middleware stack
    - Internally
        - Express keep a pointer(index) to router.stack
        - Calling next(), increment that pointer
        - Express decides which layer should run next
        - Conceptual code
            function next() {
                index++;
                runNextMatchedLayer();
            }
    - When to use next()
        - Logging middleware
        - Auth checks (if possible)
        - validation middleware
        - Any middleware that does not end the response    
    - If next() is not called in middleware, it wait forever there, it will not process further, end'sup client receives connection timeout 
    - next(err) - error mode
        - switched Express into error-handling mode
        - stops normal middleware execution
        - skip request handling
        - search for (err, req, res, next) - error-handling middleware
        - Error middleware must have 4 arguments
--------------------------------------------------------------------------------
10. Short-circuiting

    - It means intentionally stopping the request-response lifecycle before it reaches to the route handler.
    - This is essential for 
        - Authorization
        - Authentication
        - Validation
        - Rate Limiting
        - Feature flags
    - next() -> to continue & res.end() -> to stop

        -   function guard(req, res, next) {
                if(!req.header.authorization) {
                    return res.status(401).send("Missing token"); -> Stop (short-circuit)
                }
                next(); -> continue
            }

                    Layer : guard
                        ↓  token missing
                    res.send("Missing token");
                        ↓
                    res.end(); end ServerResponse stream
                        ↓
                    LifeCycle ends

        -   function auth(req, res, next) {
                const token = req.headers.authorization;
                if(!token) {
                     return res.status(401).send("unauthorized"); -> Stop (short-circuit)
                } 
                //return keyword is required to return from function, if missed end up processing next middleware.
                
                req.user = decodeToken(token);
                next();
            } 
                
        -   app.use(rateLimiter);
            app.use(auth);
            app.use(validateInput);
            app.post("/users" , handler);
--------------------------------------------------------------------------------
11. Request object internals (req)

    1. req build on Node.js IncomingMessage
        - At the node.js level, an HTTP request is represented by :
            - http.IncomingMessage - readable stream
        - TCP socket -> HTTP parser (Node core) -> IncomingMessage(req) -> ServerResponse(res)
        - Express mutate the same req object
    2. req.headers
        - Headers are parsed by the Node.js before express runs
        - This comes directly from IncomingMessage
            {
                host : "api.example.com"
                'content-type' : "application/json",
                authorization : "Bearer <token>"
            }
        - HTTP headers are case-insensitive
        e.g :   function authMiddleware(req, res, next) {
                    const authHeader = req?.headers?.authorization;

                    if(!authHeader) {
                        return res.status(401).send("Missing Authorization header");
                    }
                    if(!authHeader.startsWith("Bearer ")) {
                        return res.status(401).send("Invalid token format");
                    }

                    req.token = authHeader.slice(7) // direct mutation of req object
                    req.user = decodeToken(authHeader);
                    next();
                }
    3. req.query
        - req.query is not part of Node, it is derived by express from the URL.
        - GET /users?page=2&limit=10
        - Node give Express : req.url = "/users?page=2&limit=10"
        - Express parses the query string
        - result is attached to req.query
            - req.query = { page : '2' , limit : '10' } //values are strings
        - e.g:  
                function pagination(req, res, next) {
                    const page = Number(req.query.page || 1);
                    const limit = Number(req.query.limit || 20); //typeof value is string, we have to convert to Number

                    if(Number.isNaN(page) || Number.isNan(limit)) {
                        return res.status(400).send("Invalid pagination params");
                    }
                    req.pagination = { page, limit};
                    next();
                }
    4. req.params
        - req.params does not exist until:
            - A route matches
            - And that route has path parameters
            - e.g : app.get("/users/:id" , handler);
                    - When /users/42 matches
                    - Express extracts { id : '42' };
                    - attaches to req.params
            - Each route is a Layer with :
                - Path regex
                - Parameter keys
            - e.g : 
                  - app.get("/users/:id" , async (req, res, next) => {

                        const { id : userId } = req.params;

                        if(!/^\d+$/.test(userId)) {
                            return res.status(400).send("Invalid user id");
                        }

                        const user = await db.user.findById(userId);

                        if(!user) {
                            return res.status(404).send("User Not Found");
                        }

                        res.json(user);
                    })
    5. req.body
        - by default req.body = undefined
        - why ?
            - HTTP request bodies are stream
            - reading them consumes the streams
            - Express refuses to guess how to pass.
        - Body parsing is middleware
            - app.use(express.json())
            - Reads the stream
            - Buffers into the memory
            - Parse JSON
            - Mutates req.body
        - e.g:  app.post("/users", express.json() ,(req ,res ,next) => {
                    
                    const email = req?.body?.email;

                    if(!email) {
                        return res.status(422).send("Email is required");
                    }

                    const user = await db.users.create(req.body);
                    
                    res.status(201).json(user);
                })
    6. How middleware mutates req
        - req is one single object created by Node.js
        - Flow
                IncomingMessage (req)
                        ↓
                middleware 1 mutates req   -> app.use(logger)
                        ↓
                middleware 2 mutates req   -> app.use(auth)
                        ↓
                middleware 3 mutates req   -> app.use(loadUser)
                        ↓
                route handler reads req
        - Mutation means adding/modifying properties on req.
            - req.user = user;
            - req.token = token;
            - req.pagination = { page, limit };
            - req.context = {};
--------------------------------------------------------------------------------
12. Response object internals (res) 

    1. res built on Node.js ServerResponse
        - http.ServerResponse
        - Is created by Node for each request
        - Is a writable stream connected to the client socket
        - Represents the HTTP response socket
        - In Node we have to do everything manually:
            - res.statusCode(200);
            - res.setHeaders('Content-Type' , 'text/plain');
            - res.write("hello") //body
            - res.end();
        - What Express does
            - It takes same ServerResponse Object
            - Adds helper methods
            - Adds Convenience abstractions.
    2. res.send()
        - res.send(body) does
            1. check response state  
                - Has the response already sent (res.finished = true/false)
                - still headers are mutable ? (res.headersSet = true/false)
            2. Infer content type
                - String -> text/html
                - Object/Array -> JSON
                - Buffer -> application/octet-stream
            3. Set headers (if not already set)
                - Content-Type
                - Content-Length
            4. Write data to the socket
                - Uses Node's stream write
            5. End the response
                - Calls res.end()
        - So Conceptually
            res.send = function(body) {
                prepareHeader(body);
                writeToSocket(body);
                
                res.end();
            }
        - res.send() -> ALWAYS END THE RESPONSE
    3. res.json()
        - res.json() is fundamentally same as res.send()
        - res.json = function(obj) {
            res.setHeader('Content-Type', 'application/json');
            res.send();
        }
    4. res.end() 
        - "point of no return"
        - It is pure Node.js
        - close the writable stream and flush data to the client
        - After res.end()
            - res.finished = true
            - res.headersSet = true
            - socket is closed
            - res.status(204).end()
    5. "Headers already sent” — why it happens internally
        - "Cannot set headers after they are sent" - error
        - You are trying to HTTP headers after the response has sent back to client.
            - Calling res.send() twice
            - Calling next() after sending a response
            - Forgetting return
                - res.send("OK")
                - res.end()
--------------------------------------------------------------------------------
13. What ends the request lifecycle 

    1. res.send vs res.end 
    2. Not calling next() - request will hang forever, no return
    3. Hanging request bugs 
        - Missing return
        - Conditional logic with no exit
        - Async function that never resolves
        - Forgotten next(err)
--------------------------------------------------------------------------------
14. Sync vs async middleware behavior 

    - Express executes middleware synchronously, One layer at a time,
        - for each layer in stack:
            call layer.handler(req, res, next);
    - Express does not await anything.
    - Express does not wrap handlers in try/catch.
    - Express assumes Layers are synchronous by default.

    1. Sync throws 
            app.use((req, res, next) => {
                if(!req.headers.authorization) {
                    throw new Error("Missing auth");
                }
                next();
            })
        - Error is thrown
        - stack unwind
        - Express catches it
        - Express automatically call next(err)
        - Error-handling middleware is invoked
            - This happens during the same call stack
            - Express can intercept it

    2. Async promise rejections 
            app.use(async (req, res, next) => {
                const user = await getUser();

                if(!user) {
                    throw new Error("User not found"); // it is thrown but no one(express) is there to handle
                }

                return next();
            })
        - await pause th execution
        - promise rejects
        - Express is no longer in call stack
        - Error is unhandled
        - process may crash or hang
        - Why ?
            - Express never awaited the promise
            - Express never sees the rejection
        - Every async middleware must follow one of these patterns:
            - return next()
            - return next(err)
            - return res.send(...)

    3. Why Express doesn’t catch async errors 
        - Express predates :
            - async/await native promise in Node
        - Express assumes :
            - Middleware signals completion via:
                - next()
                - next(err)
        - It our responsibility to handler async error, Not express.
        - correct usage:

                app.use(async (req, res, next) => {
                    try {
                        const user = await getUser();
                        if(!user) {
                            return next(new Error("No user"))
                        }
                        req.user = user;

                        return next(); // return keyword used to stop Javascript execution
                    } catch(err) {
                        return next(err);
                    }
                })
        - Every async middleware must manually forward errors using next(err);
        NOTE : In Express version 5.X.X route handle promises, It will behave unlike version 4, wait for the response and return a Promise, Where handler will deal with promise
        
            - sync 
                - handler(req, res, next)
            - async
                - const result = handler(req ,res, next);

                  if(result is a Promise) {
                    result.catch(next);
                  }
--------------------------------------------------------------------------------
15. Error-Handling middleware
    - What makes a middleware make an error handler
        - It is nothing special, a pure Javascript function, which have 4 parameter and 1st one is error
        - signature
            - (err, req, res, next) => {} - error handler
            - (req, res, next) => {} normal middleware/request handler
    - How Express enters "error mode"
        - If next(err) called
        - A synchronous throws occur
        - A returned promise rejected (express 5)
    - Internal stack traversal
        - next(err) -> (err, req, res, next) => { next(err) } -> (err, req, res, next) => {}
    - Placement rules
        - must be last
    - multiple error handlers
        - app.use(logError)
        - app.use(formatError)
        - app.use(sendError)

        function logError(err, req, res, next) {
            console.log(err);
            next(err);
        }

        function sendError(err, req, res, next) {
            res.status(500).json({message : err.message})
        }
    - correct usage :
        app.user((err , req, res, next) => {
            console.log(err);

            if(req.headerSent) {
                return next(err)
            }

            res.status(500).json({ message : err.message || "Internal server error"});
        })
--------------------------------------------------------------------------------
16. Async error handling patterns (deep, descriptive)

    - This topic exist because of a fundamental mismatch between :
        - Javascript's async execution model
        - Express's middleware execution model
    - Express moves through middleware synchronously
    - Async code finishes later
    - Errors that are happened are invisible unless explicitly forwarded.

    1. why "try/catch" everywhere feels correct(but it flawed)
        - You are repeating infrastructure logic
        - Humans forget paths
        - Inconsistency across the code
    2. The async handler wrapper 
        - Wrapper (required for Express 4 and less versions)
            const asyncWrapper = fn => 
            (req, res, next) => {
                Promise
                    .resolve(fn(req, res, next))
                    .catch(next)
            }
        - Step 1: what fn really is 
            - async (req , res) => {
                    const order = await getOrder();
                    res.json(order);
              }  
            - It is async function return a promise 
        - Step 2 : What wrapper does to Express
            - Express normally does
                - handler(req, res, next)
            - The wrapper replaces that with :
                - Promise.resolve(handler(req, res, next))
                         .catch(next)
            - If the handler resolves -> nothing happens
            - If the handler rejects -> next(err) is called
            - This is the exact signal Express needs to enter error mode
        - Step 3 : Why Promise.resolve() is used
            - Promise.resolve() ensure
                - Sync handler still work
                - Sync throw becomes a rejected Promise
                - Async and Sync handlers behave the same
            - This unifies all failure modes into one pipeline
    3. How this changes your route code 
        - Without wrapper, your brain must track:
            - where errors are caught
            - whether next(err) is called
            - whether return is missing
        - With wrapper, your brain can assume:
            - "Any thrown or rejected error will reach the error middleware"
            - async function → returns a Promise
            - normal function → returns a value or throws synchronously
            - router.get(
                    "/orders/:id", 
                    asyncHandler(async (req, res) => {
                        const order = await getOrder(req.params.id);

                        if(!order) {
                            return res.status(404).send();
                        }

                        res.json(order)
                    })
               );
            - All async failure will call next(err)
            - All errors arrive at :
                - app.use((err ,req ,res, next) => {})
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------