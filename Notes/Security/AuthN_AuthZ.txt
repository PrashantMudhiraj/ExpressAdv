Phase 0 - Cryptography Foundations

    0.1 - Terminologies
        - Plain Text: Data in its original, readable form.
            - Example: password123
        - Ciphertext: Unreadable, transformed version of plain text after cryptographic operation.
            - Example: 983089703n83ebx2z211097as349kw122
        - Key: A Secret value used to transform data
            - This is the actual power in cryptography, *No Security without a key*.
        - Encryption: Converting plaintext -> ciphertext using a key, so it can be reversed later
            - Important property : 
                - Reversible
            - Used when data must be read again later
        - Decryption: Converting ciphertext -> plaintext using a key
            - Only someone with the correct key can decrypt
        - Hash: A one-way transformation of data
            - Key properties:   
                - Cannot be reversed
                - Same input -> Same output
        - Salt: Random data added to input before hashing
            - Why it exists:
                - Prevents precomputed attacks(rainbow tables)
            - Salt is not secret -> it is stored with the hash
        - Signature: Cryptography proof that:
            - Data was created by a trusted party
            - Data was not modified
            - Signature = integrity + authenticity, not secrecy
        
        - Cryptography solve three  fundamental problems
            - Keep data secret -> Solved by encryption
            - Store secret safely -> Solved by Hashing
            - Prove trust -> Solved by Signatures
            
        - WHy these are used?
            - Why encryption?
                - Protect data in transit(HTTPS)
                - Protect data at rest(DB, backups)
            - Why hashing?
                - Password storage
                - verifying integrity
            - Why signatures?
                - JWT trusts
                - OAuth tokens
                - API authentication
        
        - data + private key -> signature
        - data + public key -> verification
        - Private key sign data
        - Public key verifies signature
        - Data cannot be altered without breaking signature

        - Hashing

                import crypto from "crypto";
                /**
                * crypt is a built in node.js module
                * Provides cryptographic primitives (hashing, encryption, random bytes)
                * No external npm package needed
                *
                * createHash('sha2456'):
                *  - creates a hash function
                *  - sha256 is a cryptographic hash algorithm
                *  - output size : 256 bits
                *
                * update(password)
                *  - Feed input data into the hash function
                *  - You can call update() multiple times for streams
                *
                * digest('hex')
                *  - Finalize the hash
                *  - Converts binary output -> hex string(readable)
                *
                * Hashes the password
                * output looks random
                * Same input -> Same output
                *
                * In production, we do not use raw SHA-256 for passwords
                * We use bcrypt or argon
                */

                function hashPassword(password) {
                    const hash = crypto.createHash("sha256").update(password).digest("hex");
                    console.log(hash);
                    return hash;
                }

                hashPassword("password123");

        - Encrypt & Decrypt

                import crypto from "crypto";

                /**
                * crypto.randomBytes(32)
                *  - Generate a random symmetric key
                *  - 32 bytes = 256 bits
                *  - Used by AES-256
                *
                * crypto.randomBytes(16)
                *  - IV = Initializer vector
                *  - Adds randomness
                *  - Prevents identical plaintext from production identical ciphertext
                *  - IV is not secret, but must be unique
                *
                * crypto.createCipheriv('aes-256-cbc', key, iv);
                *  - Creates an AES cipher
                *  - aws-256-cbc
                *      - AES algorithm
                *      - 256-bits
                *      - CBC mode -> Cipher Blocking chain
                *          - CBC is used here for demo; GCM is preferred in real systems
                * crypto.update(text,'utf-8','hex') + cipher.final('hex');
                *  - update() -> encrypt data
                *  - utf-8 -> input encoding
                *  - hex -> output encoding
                *  - final() -> finishes encryption
                *
                * crypto.createDecipheriv('aes-256-cbc', key, iv);
                *  - Uses same algorithm
                *  - Uses same key
                *  - Uses same IV
                *
                * - This is why symmetric crypto is called symmetric
                */

                const key = crypto.randomBytes(32);
                console.log(key);
                const iv = crypto.randomBytes(16);
                console.log(iv);

                function encrypt(text) {
                    const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
                    return cipher.update(text, "utf-8", "hex") + cipher.final("hex");
                }

                function decrypt(encrypted) {
                    const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
                    return decipher.update(encrypted, "hex", "utf-8") + decipher.final("utf-8");
                }

                const secret = encrypt("hello");
                console.log(decrypt(secret));

                /**
                * Block Cipher : An Encryption algorithm that works on fixed-size blocks of data. Can encrypt only one block at a time.
                * Stream Cipher : An Encryption algorithm that encrypts data bit-by-bit or byte-by-byte
                * Block Cipher Mode : A method that tells the cipher how to encrypt data longer than one block. (CBC one of them)
                * CBC (Cipher Block Chaining) : A block cipher mode of operation
                *  - CBC chains blocks together so that:
                *      - Each block depends on the previous block
                * IV (Initialization vector) : A random value used only for first block of operation
                */
            
        - AES (Advanced Encryption Standard)   
            - It is Encryption algorithm used to convert plaintext to ciphertext using a key.
            - A symmetric encryption algorithm
            - Used worldwide as the standard for data encryption
            - Default choice for:
                - HTTPS
                - Disk encryption
                - Database
                - Cloud storage
                - JWT(when encrypted, JWE)



--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
x. OAuth 2.0 
	1.1 Terminology
	    - Resource Owner(me): Entity that can grant access to a protected resource. Typically this is end user.
	    - Client(any app that contact access): Application requesting access to a protected resource on behalf of the Resource Owner
	    - Resource Server(google.contacts.api): Server hosting the protected resources. This is the API you want to access
	    - Authorization Server(accounts.google.com): Server that authenticates the Resource Owner and issues Access Tokens after getting proper authentication. In this case AuthO.
	    - Authorization grant: That proves User approved/granted access for protected resource
	    - Redirect URI : callback url, Once AuthZ done, It will redirect to redirect_uri
	    - Access token: It is a secure, temporary digital key or credential that allows an application to access specific resources (like an API or data) on behalf of a user, without needing their password repeatedly
	    - User Agent: Agent used by the resource owner to interact with the client(example, a browser or a native application)
		- Scope: It defines the specific actions application can be allowed to do on user's behalf
		- Back channel (highly secure channel): Backend server
		- Front channel (less secure channel): Frontend App

	1.2 Flows 
		- Authorization code(front channel + back channel)
		- Implicit(front channel only)

		- Resource owner password credentials(back channel only)
		- Client credentials(back channel only)

2. Problems with OAuth 2.o for authentication
	- No standard way to get the user's information
	- Every implementation is a little different
	- No common set of scopes

3. OAuth 2.0 and OpenID connect
	- OpenID Connect is for authentication
	- OAuth 2.0 is for authorization
--------------------------------------------------------------------------------------------


