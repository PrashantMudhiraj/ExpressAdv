1. REST principles (practical)

    - INTRO
        - REST is a set of architectural constraints(non-negotiable boundaries) that leverages(to build upon) HTTP's existing semantics(which are already existing such as methods)
        - REST -> REpresentational State Transfer (architectural style)
        - REST introduced to answer below one question :
            - How do we design APIs that keeps working when it grows and changes?
        - REST is not about any framework
        - REST is about rules that make APIs scalable and predictable
        - REST uses HTTP properly
            - URLs
            - Methods (GET, POST, etc..)
            - Status Code
            - Headers
            - REST say's don't fight with HTTP, Use it as it is designed.
        - URI - Uniform Resource Identifier
        - URL - Uniform Resource Location

    1. Resource-oriented design
        - What does "resource" mean?
            - In Rest, the focus is on "Resource" rather than "action"
            - Resource is a thing, It is not a function/button/action. 
                - Examples of things are Order, Customer, Payment. (resource)
                - Examples of Not things(function/button/action) are createOrder/cancelOrder/shipOrder
                - REST hates action based URL's (Remote Procedure Call - RPC style routing) 
                    - POST /createOrder
                    - POST /cancelOrder
                    - The URL describes what you want to do(createOrder , cancelOrder), not what you are working with (order, payment, customer)
                - URL's should point to things, not actions.
                    - "what action am i performing?"
                    - "what thing am i working with?"
                        - /orders -> all orders
                        - /orders/123 -> one specific order
                    - HTTP methods are taking care of actions
                        - GET  -> give me data
                        - POST -> create something new
                        - PATCH -> update existing data
                        - DELETE -> remove something
                - So,
                    - POST /orders -> create order
                    - GET /orders/1 -> get order
                    - PATCH /orders/1 -> change order

    2. Stateless
        - Stateless means,"The Server does not remember you from previous request"
        - For every request must include:
            1. Who you are(token)
            2. What resource you want(URL)
            3. What you want to do(HTTP method)
            4. Any required data(body/query)
                GET /orders/123
                Authorization: Bearer <token>
        - The server : 
            - Reads token
            - Check permissions
            - Fetch order
            - Sends response
            - Forgets everything
        - Why this fails in production (state full):
            - Production Express apps run in multiple instances (using PM2 clusters or Kubernetes pods). If Request 1 goes to Instance A and Request 2 goes to Instance B, Instance B has no idea about the state stored in Instance A. The client’s experience becomes inconsistent and buggy

    3. Client-server separation
        - Client and Server have different jobs
            - Client(frontend, mobile app): The Client owns the UI and the user experience
                - Decide user flow
                - Handles screen and buttons
            - Server : The server owns the data and business logic
                - Stores data
                - Applies rules
                - Return results
        - The Server doesn't care about UI flows

        - What is the thing ? -> resource
        - What do i want to do to it ? -> HTTP method
        - What changed ? -> representation(JSON)
        - REST is "changing the state of things using HTTP rules"
------------------------------------------------------------------------------------------------
2. Resource naming & URL design 

    1. Nouns vs verbs
        - URLs name things.
        - HTTP methods describe action
        - If the URL contains a verb, it's usually wrong (verb based URLs)
            - This is bad because URLs describe actions
            - HTTP methods becomes meaningless
            - Everything turns into POST
            - API become hard to reason about
                - /createOrder
                - /getOrders
                - /cancelOrder
                - /updateOrderStatus 
        - Good (noun based URLs)
            - /orders
            - /orders/123
            - Now actions are expressed by HTTP methods
                Action          Method      URL
                ------------    ------      -----------
                Create order    POST        /orders
                Get order       GET         /orders/123
                update order    PATCH       /orders/123
                Delete order    DELETE      /orders/123
            - URL stay stable, method changes the behavior

    2. Pluralization
        - Why /orders is plural
        - In Rest, a URL can represent:
            - A collection of resources
            - A single member of that collection
            - GET /orders - Returns a collection of orders.
            - GET /orders/:id - Returns a specific instance from a collection.
        - using pluralization consistently prevents ambiguity. If you use /order, does is refer a collection or a single order ?
        - using /orders clearly identifies a collection.

    3. Nested resources
        - URLs should reflects relationship between resources. If a resource belongs to another, The URI structure should show that hierarchy.
        - Resource does not make sense without parent.
        - orderItem cannot exit without an order.
            - /orders/123/items -> single order with multiple order items
            - /orders/123/items/456 -> single order with single order item.
        - Internal Execution (The "mergeParams" constraint) ;
            - When you see Nested parameters, The Child router's does have access to parent req.params by default. T
            - This is an internal design choice to keep routers isolated. 
            - To access parent req.params, we should manually enable it.
                - e.g:

                    const orderRouter = express.Router();
                    const orderItemRouter = express.Router({ mergeParams :  true });

                    orderRouter.use("/:orderId/Items", orderItemRouter);

                    orderItemRouter("/:orderItemId" , (req , res) => {
                        const { orderId, orderItemId } = req.params;

                        res.json({ orderId, orderItemId })
                    })
        
    4. Avoid deep nesting
        - maximum hierarchy we should consider is 2(levels)
        - to avoid complexity (authorization)
        - For scalability
        - tight coupling
        - Industry rule of thumb
            - "At most one level of nesting beyond the root resource"
        
        Drawbacks:
            1. Regex Complexity : Internally, Express converts these paths into complex regular expression. Longer path is directly increasing the loaf/work on path-to-regex.
            2. Client burden : for every request client needs to send different Id's
            3. Database coupling : Your API structure becomes strictly tied to your database schema hierarchy.
------------------------------------------------------------------------------------------------
3. HTTP methods

    - In RESTful API design, HTTP methods(often called verb) define the action to be performed on the resource identified by the URI.

        1. GET method:
            - I want current representation of this resource. I am not changing anything.
            - Correct usage :
                - GET /orders/123
                - Fetch order 123

                    app.get("/order/:id", async (req, res) => {
                        const { id } = req.params;
                        const order = await orderService.getById(id);

                        if(!order) {
                            return res.status(404).json({ message : "order not found"})
                        }

                        res.json(order);
                    })

            - Key Properties :
                - No mutation
                - No counters
                - No logging that affects business state

        2. POST method:
            - Please create a new subordinate resource under this collection
            - It is used to create a new entity to the specified resource, often resulting in a change in state or side effects on the server
            - * POST is not idempotent *
            - * calling it twice may create two resources (duplicates)*
            - e.g :
                - POST /orders
                
                    app.post("/orders', express.json(), (req, res) => {
                        /* IMPORTANT : before creating resource we must sanitize(validations) the request. */
                        const order = await orderService.create(req.body);
                        res.status(201).json(order);
                    })

        3. PUT method:
            - Replace the entire state of the resource with what I'm sending
            - It is not a partial update it is Complete replacement of resource by request body
            - PUT is dangerous
                - Missing fields amy be overwritten or removed
                - Accidental data loss in common.
            - PUT is idempotent, because  if you send the exact same request 10 times, the state of the server is same as after the first request
            - PUT /orders/123
                {
                    status : "shipped"
                }
                - data loss like orderId, shipping details etc..

        4. PATCH method:
            - Partial update, Apply these changes on the existing resource
            - It does not replace everything
            - e.g:
                - PATCH /orders/123

                    app.patch("/orders/:id", express.json() , async(req, res, next) => {
                        const { id } = req.params;
                        const data =  req.body;
                        const updated = await orderService.update( id, data);

                        res.json(updated);
                    })
            - Typical use cases :
                - update shipping status
                - update shipping address
                - cancel an order
            - Safer than PUT, as it is partial update

        5. DELETE method:
            - Remove this resource
            - Data is often soft-deleted
            - Resource may be marked as inactive
            - e.g:
                - DELETE /orders/123

                    app.delete("/orders/:id" , async (req, res) => {
                        const { id } = req.params;

                        await orderService.delete(id);

                        res.status(204).end(); 
                    })
                - Why 204 No content:
                    - Resource is gone
                    - No response body needed
        
        6. OPTIONS method:
            - What is allowed to be done with this resource ?
            - An OPTIONS request asks the server :
                - For this URL, which HTTP methods, headers and behaviors are supported ?
                - e.g :
                    - OPTIONS /orders/123
                    - The server will respond with capabilities, not data
            - This is essential for :
                - CORS
                - API gateways
                - Security enforcement
                - Client tooling
            - OPTIONS and CORS (Most Common Real-World Use)
                - The real problem browsers have
                - * Browsers enforces Same-Origin Policy *:
                    - Javascript cannot freely call API's of other domain
                    - This is security rule, not a backend choice.
            - What triggers a CORS preflight ?
                - A browser sends a OPTIONS when:
                    - Method is not GET/POST
                    - OR custom headers are used
                    - OR content-type is not simple (application/json often triggers it)
                    - e.g :
                        - PATCH /orders/123
                        - Authorization: Bearer <token>
                        - Content-type : application json
                    - Browser behavior:
                        1. Sends OPTIONS first
                        2. Ask permissions
                        3. Only then send PATCH
                    - Preflight OPTIONS request
                        - OPTIONS /orders/123
                        - Origin: https://frontend.example.com
                        - Access-Control-Request-Method: PATCH
                        - Access-Control-Request-Headers: Authorization, Content-Type
                    - Expected Response
                        - HTTP/1.1 204 No Content
                        - Access-Control-Allow-Origin: https://frontend.example.com
                        - Access-Control-Allow-Methods: GET, PATCH, DELETE  //yes, you are allowed to do this
                        - Access-Control-Allow-Headers: Authorization, Content-Type
            - OPTIONS is about permissions, Not Data
            - e.g :
                        app.get("/orders/:id",() => {})
                        app.patch("/orders/:id",() => {})
                        app.delete("/orders/:id",() => {})
                - This route support GET, PATCH, DELETE, So an OPTIONS request returns:
                    - Access-Control-Allow-Methods : GET, PATCH, DELETE
            - When you Must Handle OPTIONS explicitly
                1. You implements customs CORS logic
                2. You block or allow methods dynamically
                3. You sit behind strict API gateway

                - e.g:  
                        app.options("/orders/:id" , (req, res)) => {
                            res.set({
                                Access-Control-Allow-Methods: 'GET, PATCH, DELETE',
                                Access-Control-Allow-Headers: 'Authorization, Content-Type'
                            })

                            res.sendStatus(204);
                        }
------------------------------------------------------------------------------------------------
4. Safe vs Idempotent HTTP Methods
    - In distributed systems, requests WILL be retried.
    - In distributed systems, network failures are inevitable. A client might send a request, the server might process it successfully, but the network might drop the response before it reaches the client. This is where the concepts of Safety and Idempotency become critical for building resilient backends.
    - safe and Idempotent semantics are exist so retries don't corrupt data.
    - Scenario
        - Network drops after server processes the request(not sent back to client)
        - Load balancer times out
        - Client crashes mid-request
        - reverse proxy retires
        - Mobiles network resend request
        - What happens if same request is executed again ?
            - safe and idempotent methods are the answer to this question

    1. Safe Methods
        - A method is called as safe, when execution does not effect the server state. no matter how many times it is called.
        - Safety is about side effects, not logic
        - Methods : GET, HEAD, OPTIONS
            - GET is the primary safe method
                - GET /orders/123
                - No database writes
                - No counter incremented
                - No state transitions
                - No 'last accessed flag"
                
                - We are allowed to
                    - Read data from DB
                    - compute derived data
                    - Log access
    
    2. Idempotent Methods - Same Result, Every Time
        - A method is Idempotent if the side effects of making request multiple times is same as making it exactly one
        - mathematically: f(x) = f(f(x))
            - Idempotent !== Safe
            - Idempotent can change the state.
        - All Safe methods are idempotent, Not all idempotent are safe methods
        - Idempotent methods: GET, HEAD, PUT, DELETE, OPTIONS
            - GET -> getting data from server
            - PUT -> replace the existing resource
            - DELETE -> intent is to delete the resource (first request-> 204, second request-> 404)
            - OPTIONS -> does not affect the state 
        - Non-Idempotent methods: POST
            - POST will create duplicate resource again and again.
        - The Tricky case : PATCH is generally not guaranteed to be idempotent
            - PATCH applies changes, not replacements
            - If PATCH sets state explicitly
                - It may be idempotent
            - But consider:
                - PATCH /orders/123
                    {
                        amount : "+100";
                    }
                - Amount increases for every request(risky)
        - *Important*
            - GET -> Must be side-effect free
            - DELETE -> Must be safe to retry
            - POST -> Must assume retires will happen and Must be protected when money or inventory is involved
            - PATCH -> Must be explicit about state transition
------------------------------------------------------------------------------------------------
5. Proper HTTP status codes
    - Status codes are not decorations. There are primary signals to the distributed systems
    - The HTTP status code is the primary metadata the server provides to the client. It allows client to decide the next move
    - In Production, many actors consume your API;
        - Browser
        - Mobile Apps
        - Load balancers
        - API gateways
        - Retry mechanism
        - Monitoring tools
        - Alerting systems
    - Most of them, do not prase the response body(JSON), Only look for status code
    - So, the Status code is your API's truth signal

    - Codes
        - 200 vs 201 “Success” Is Not One Thing
            - 200 -> "The request succeeded"
                - Use 200 when
                    - You successfully retrieved the data
                    - You successfully updated the data
                    - The resource already exist
                        - GET /orders/123 -> 200 OK
                        - PATCH /orders/123 -> 200 OK
            - 201 -> "A new resource now exists"
                - Use 201 when
                    - A new resource is created
                    - The Server generated the resource identity
                        - POST /orders/123 -> 201 created
                        - e.g:
                                app.post("/order" , async(req, res) => {
                                    const order =  await orderService.create(req.body);
                                    res.status(201).json(order);
                                })
                    - If we do not mention status code, By default Node send 200 code. -> res.json(order)

        - 204 No Content - "Success, but nothing return"
            - The request succeeded, and there is no response body.
                - Use 204 when
                    - DELETE operations
                    - Some idempotent updates
                    - DELETE /orders/123 -> 204 No Content
                    - e.g:  
                            app.delete("/orders/123",async (req , res) => {
                                await orderService.remove(req.params.id);
                                res.status(204).end(); // do not use send -> send will check content-type etc.. which is not required
                            })

        - 400 vs 422 Syntax vs Semantics
            - 400 Bad Request -> "I cannot parse this request"
                - Use 400 when:
                    - JSON is malformed
                    - Required fields are missing in the request
                    - Request format is in correct.
                        - POST /orders
                            { invalid JSON } -> 400 Bad Request
            - 422 Unprocessable Entity - "Request is valid, but wrong"
                - Use 422 when:
                    - JSON is valid
                    - But values violates the business rules
                        - POST /orders
                            {
                                quantity : -5
                            }
                            -> 422 Unprocessable Entity
            - Fix 400 by correcting format
            - Fix 422 by correcting data

        - 401 vs 403 Authentication vs Authorization
            - 401 Unauthorized - "Who are you?"
                - Use 401 when:
                    - Missing token
                    - Invalid token
                    - Expires token
                        - GET /orders/123
                            { no Authorization header }
                            -> 401 Unauthorized
            - 403 Forbidden - "I know who you are(authenticated), but not allowed"
                - Use 403 when:
                    - Scope/roles missing
                        - GET /orders/123
                            (user does not own this resource)
                            -> 403 Forbidden

        - 404 vs 409 - Absence vs Conflict
            - 404 Not Found — “Resource does not exist”
                - Use 404 when;    
                    - The resource Id does not exist
                    - The URL is valid, but the resource isn't
                        - GET /orders/999
                            -> 404 Not Found
            - 409 Conflict - "State Conflict"
                - Use 409 when:
                    - The request conflict with the current state
                        - PATCH /orders/123
                            {
                                status : "shipped"
                            } 
                        - But the order is cancelled
                        - 409 Conflict
                - Mostly use it for business logic

        - 500 vs 503 - Your Fault(server) vs Temporary Failure
            - 500 Internal server error - "Bug"
                - Use 500 when"
                    - unhandled exception
                    - Programming error
                    - Inconsistent state
                    - This means server is broken.
            - 503 service unavailable - "Try again later"
                - Use 503 when:
                    - Database is down
                    - Dependency is unavailable
                    - System is overloaded
                - 503 signals
                    - Temporary failure
                    - Retry must succeed
                - This is critical for :
                    - Retry logic
                    - Circuit breakers
                    - Auto Scaling
        - Status Codes Drive Client Behavior
            if(res.status >= 500) retry();
            if(res.status === 401) redirectToLogin();
            if(res.status === 422) showValidationErrors();

        - 3XX status codes - Redirection and Control Flow
            - The resource you want is somewhere else, or should be accessed differently
            - 301 Moved Permanently
                - This resource has a new permanent URL
                    - Response includes:   
                        Location /new-url
            - 302 Found (Temporary redirect)
                - This resource is temporarily available elsewhere


            

------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
