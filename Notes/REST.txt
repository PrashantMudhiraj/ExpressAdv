1. REST principles (practical)

    - INTRO
        - REST is a set of architectural constraints(non-negotiable boundaries) that leverages(to build upon) HTTP's existing semantics(which are already existing such as methods)
        - REST -> REpresentational State Transfer (architectural style)
        - REST introduced to answer below one question :
            - How do we design APIs that keeps working when it grows and changes?
        - REST is not about any framework
        - REST is about rules that make APIs scalable and predictable
        - REST uses HTTP properly
            - URLs
            - Methods (GET, POST, etc..)
            - Status Code
            - Headers
            - REST say's don't fight with HTTP, Use it as it is designed.
        - URI - Uniform Resource Identifier
        - URL - Uniform Resource Location

    1. Resource-oriented design
        - What does "resource" mean?
            - In Rest, the focus is on "Resource" rather than "action"
            - Resource is a thing, It is not a function/button/action. 
                - Examples of things are Order, Customer, Payment. (resource)
                - Examples of Not things(function/button/action) are createOrder/cancelOrder/shipOrder
                - REST hates action based URL's (Remote Procedure Call - RPC style routing) 
                    - POST /createOrder
                    - POST /cancelOrder
                    - The URL describes what you want to do(createOrder , cancelOrder), not what you are working with (order, payment, customer)
                - URL's should point to things, not actions.
                    - "what action am i performing?"
                    - "what thing am i working with?"
                        - /orders -> all orders
                        - /orders/123 -> one specific order
                    - HTTP methods are taking care of actions
                        - GET  -> give me data
                        - POST -> create something new
                        - PATCH -> update existing data
                        - DELETE -> remove something
                - So,
                    - POST /orders -> create order
                    - GET /orders/1 -> get order
                    - PATCH /orders/1 -> change order

    2. Stateless
        - Stateless means,"The Server does not remember you from previous request"
        - For every request must include:
            1. Who you are(token)
            2. What resource you want(URL)
            3. What you want to do(HTTP method)
            4. Any required data(body/query)
                GET /orders/123
                Authorization: Bearer <token>
        - The server : 
            - Reads token
            - Check permissions
            - Fetch order
            - Sends response
            - Forgets everything
        - Why this fails in production (state full):
            - Production Express apps run in multiple instances (using PM2 clusters or Kubernetes pods). If Request 1 goes to Instance A and Request 2 goes to Instance B, Instance B has no idea about the state stored in Instance A. The client’s experience becomes inconsistent and buggy

    3. Client-server separation
        - Client and Server have different jobs
            - Client(frontend, mobile app): The Client owns the UI and the user experience
                - Decide user flow
                - Handles screen and buttons
            - Server : The server owns the data and business logic
                - Stores data
                - Applies rules
                - Return results
        - The Server doesn't care about UI flows

        - What is the thing ? -> resource
        - What do i want to do to it ? -> HTTP method
        - What changed ? -> representation(JSON)
        - REST is "changing the state of things using HTTP rules"
------------------------------------------------------------------------------------------------
2. Resource naming & URL design 

    1. Nouns vs verbs
        - URLs name things.
        - HTTP methods describe action
        - If the URL contains a verb, it's usually wrong (verb based URLs)
            - This is bad because URLs describe actions
            - HTTP methods becomes meaningless
            - Everything turns into POST
            - API become hard to reason about
                - /createOrder
                - /getOrders
                - /cancelOrder
                - /updateOrderStatus 
        - Good (noun based URLs)
            - /orders
            - /orders/123
            - Now actions are expressed by HTTP methods
                Action          Method      URL
                ------------    ------      -----------
                Create order    POST        /orders
                Get order       GET         /orders/123
                update order    PATCH       /orders/123
                Delete order    DELETE      /orders/123
            - URL stay stable, method changes the behavior

    2. Pluralization
        - Why /orders is plural
        - In Rest, a URL can represent:
            - A collection of resources
            - A single member of that collection
            - GET /orders - Returns a collection of orders.
            - GET /orders/:id - Returns a specific instance from a collection.
        - using pluralization consistently prevents ambiguity. If you use /order, does is refer a collection or a single order ?
        - using /orders clearly identifies a collection.

    3. Nested resources
        - URLs should reflects relationship between resources. If a resource belongs to another, The URI structure should show that hierarchy.
        - Resource does not make sense without parent.
        - orderItem cannot exit without an order.
            - /orders/123/items -> single order with multiple order items
            - /orders/123/items/456 -> single order with single order item.
        - Internal Execution (The "mergeParams" constraint) ;
            - When you see Nested parameters, The Child router's does have access to parent req.params by default. T
            - This is an internal design choice to keep routers isolated. 
            - To access parent req.params, we should manually enable it.
                - e.g:

                    const orderRouter = express.Router();
                    const orderItemRouter = express.Router({ mergeParams :  true });

                    orderRouter.use("/:orderId/Items", orderItemRouter);

                    orderItemRouter("/:orderItemId" , (req , res) => {
                        const { orderId, orderItemId } = req.params;

                        res.json({ orderId, orderItemId })
                    })
        
    4. Avoid deep nesting
        - maximum hierarchy we should consider is 2(levels)
        - to avoid complexity (authorization)
        - For scalability
        - tight coupling
        - Industry rule of thumb
            - "At most one level of nesting beyond the root resource"
        
        Drawbacks:
            1. Regex Complexity : Internally, Express converts these paths into complex regular expression. Longer path is directly increasing the loaf/work on path-to-regex.
            2. Client burden : for every request client needs to send different Id's
            3. Database coupling : Your API structure becomes strictly tied to your database schema hierarchy.
------------------------------------------------------------------------------------------------
3. HTTP methods

    - In RESTful API design, HTTP methods(often called verb) define the action to be performed on the resource identified by the URI.

        1. GET method:
            - I want current representation of this resource. I am not changing anything.
            - Correct usage :
                - GET /orders/123
                - Fetch order 123

                    app.get("/order/:id", async (req, res) => {
                        const { id } = req.params;
                        const order = await orderService.getById(id);

                        if(!order) {
                            return res.status(404).json({ message : "order not found"})
                        }

                        res.json(order);
                    })

            - Key Properties :
                - No mutation
                - No counters
                - No logging that affects business state

        2. POST method:
            - Please create a new subordinate resource under this collection
            - It is used to create a new entity to the specified resource, often resulting in a change in state or side effects on the server
            - * POST is not idempotent *
            - * calling it twice may create two resources (duplicates)*
            - e.g :
                - POST /orders
                
                    app.post("/orders', express.json(), (req, res) => {
                        /* IMPORTANT : before creating resource we must sanitize(validations) the request. */
                        const order = await orderService.create(req.body);
                        res.status(201).json(order);
                    })

        3. PUT method:
            - Replace the entire state of the resource with what I'm sending
            - It is not a partial update it is Complete replacement of resource by request body
            - PUT is dangerous
                - Missing fields amy be overwritten or removed
                - Accidental data loss in common.
            - PUT is idempotent, because  if you send the exact same request 10 times, the state of the server is same as after the first request
            - PUT /orders/123
                {
                    status : "shipped"
                }
                - data loss like orderId, shipping details etc..

        4. PATCH method:
            - Partial update, Apply these changes on the existing resource
            - It does not replace everything
            - e.g:
                - PATCH /orders/123

                    app.patch("/orders/:id", express.json() , async(req, res, next) => {
                        const { id } = req.params;
                        const data =  req.body;
                        const updated = await orderService.update( id, data);

                        res.json(updated);
                    })
            - Typical use cases :
                - update shipping status
                - update shipping address
                - cancel an order
            - Safer than PUT, as it is partial update

        5. DELETE method:
            - Remove this resource
            - Data is often soft-deleted
            - Resource may be marked as inactive
            - e.g:
                - DELETE /orders/123

                    app.delete("/orders/:id" , async (req, res) => {
                        const { id } = req.params;

                        await orderService.delete(id);

                        res.status(204).end(); 
                    })
                - Why 204 No content:
                    - Resource is gone
                    - No response body needed
        
        6. OPTIONS method:
            - What is allowed to be done with this resource ?
            - An OPTIONS request asks the server :
                - For this URL, which HTTP methods, headers and behaviors are supported ?
                - e.g :
                    - OPTIONS /orders/123
                    - The server will respond with capabilities, not data
            - This is essential for :
                - CORS
                - API gateways
                - Security enforcement
                - Client tooling
            - OPTIONS and CORS (Most Common Real-World Use)
                - The real problem browsers have
                - * Browsers enforces Same-Origin Policy *:
                    - Javascript cannot freely call API's of other domain
                    - This is security rule, not a backend choice.
            - What triggers a CORS preflight ?
                - A browser sends a OPTIONS when:
                    - Method is not GET/POST
                    - OR custom headers are used
                    - OR content-type is not simple (application/json often triggers it)
                    - e.g :
                        - PATCH /orders/123
                        - Authorization: Bearer <token>
                        - Content-type : application json
                    - Browser behavior:
                        1. Sends OPTIONS first
                        2. Ask permissions
                        3. Only then send PATCH
                    - Preflight OPTIONS request
                        - OPTIONS /orders/123
                        - Origin: https://frontend.example.com
                        - Access-Control-Request-Method: PATCH
                        - Access-Control-Request-Headers: Authorization, Content-Type
                    - Expected Response
                        - HTTP/1.1 204 No Content
                        - Access-Control-Allow-Origin: https://frontend.example.com
                        - Access-Control-Allow-Methods: GET, PATCH, DELETE  //yes, you are allowed to do this
                        - Access-Control-Allow-Headers: Authorization, Content-Type
            - OPTIONS is about permissions, Not Data
            - e.g :
                        app.get("/orders/:id",() => {})
                        app.patch("/orders/:id",() => {})
                        app.delete("/orders/:id",() => {})
                - This route support GET, PATCH, DELETE, So an OPTIONS request returns:
                    - Access-Control-Allow-Methods : GET, PATCH, DELETE
            - When you Must Handle OPTIONS explicitly
                1. You implements customs CORS logic
                2. You block or allow methods dynamically
                3. You sit behind strict API gateway

                - e.g:  
                        app.options("/orders/:id" , (req, res)) => {
                            res.set({
                                Access-Control-Allow-Methods: 'GET, PATCH, DELETE',
                                Access-Control-Allow-Headers: 'Authorization, Content-Type'
                            })

                            res.sendStatus(204);
                        }
------------------------------------------------------------------------------------------------
4. Safe vs Idempotent HTTP Methods

    - In distributed systems, requests WILL be retried.
    - In distributed systems, network failures are inevitable. A client might send a request, the server might process it successfully, but the network might drop the response before it reaches the client. This is where the concepts of Safety and Idempotency become critical for building resilient backends.
    - safe and Idempotent semantics are exist so retries don't corrupt data.
    - Scenario
        - Network drops after server processes the request(not sent back to client)
        - Load balancer times out
        - Client crashes mid-request
        - reverse proxy retires
        - Mobiles network resend request
        - What happens if same request is executed again ?
            - safe and idempotent methods are the answer to this question

    1. Safe Methods
        - A method is called as safe, when execution does not effect the server state. no matter how many times it is called.
        - Safety is about side effects, not logic
        - Methods : GET, HEAD, OPTIONS
            - GET is the primary safe method
                - GET /orders/123
                - No database writes
                - No counter incremented
                - No state transitions
                - No 'last accessed flag"
                
                - We are allowed to
                    - Read data from DB
                    - compute derived data
                    - Log access
    
    2. Idempotent Methods - Same Result, Every Time
        - A method is Idempotent if the side effects of making request multiple times is same as making it exactly one
        - mathematically: f(x) = f(f(x))
            - Idempotent !== Safe
            - Idempotent can change the state.
        - All Safe methods are idempotent, Not all idempotent are safe methods
        - Idempotent methods: GET, HEAD, PUT, DELETE, OPTIONS
            - GET -> getting data from server
            - PUT -> replace the existing resource
            - DELETE -> intent is to delete the resource (first request-> 204, second request-> 404)
            - OPTIONS -> does not affect the state 
        - Non-Idempotent methods: POST
            - POST will create duplicate resource again and again.
        - The Tricky case : PATCH is generally not guaranteed to be idempotent
            - PATCH applies changes, not replacements
            - If PATCH sets state explicitly
                - It may be idempotent
            - But consider:
                - PATCH /orders/123
                    {
                        amount : "+100";
                    }
                - Amount increases for every request(risky)
        - *Important*
            - GET -> Must be side-effect free
            - DELETE -> Must be safe to retry
            - POST -> Must assume retires will happen and Must be protected when money or inventory is involved
            - PATCH -> Must be explicit about state transition
------------------------------------------------------------------------------------------------
5. Proper HTTP status codes

    - Status codes are not decorations. There are primary signals to the distributed systems
    - The HTTP status code is the primary metadata the server provides to the client. It allows client to decide the next move
    - In Production, many actors consume your API;
        - Browser
        - Mobile Apps
        - Load balancers
        - API gateways
        - Retry mechanism
        - Monitoring tools
        - Alerting systems
    - Most of them, do not prase the response body(JSON), Only look for status code
    - So, the Status code is your API's truth signal

    - Codes
        - 200 vs 201 “Success” Is Not One Thing
            - 200 -> "The request succeeded"
                - Use 200 when
                    - You successfully retrieved the data
                    - You successfully updated the data
                    - The resource already exist
                        - GET /orders/123 -> 200 OK
                        - PATCH /orders/123 -> 200 OK
            - 201 -> "A new resource now exists"
                - Use 201 when
                    - A new resource is created
                    - The Server generated the resource identity
                        - POST /orders/123 -> 201 created
                        - e.g:
                                app.post("/order" , async(req, res) => {
                                    const order =  await orderService.create(req.body);
                                    res.status(201).json(order);
                                })
                    - If we do not mention status code, By default Node send 200 code. -> res.json(order)

        - 204 No Content - "Success, but nothing return"
            - The request succeeded, and there is no response body.
                - Use 204 when
                    - DELETE operations
                    - Some idempotent updates
                    - DELETE /orders/123 -> 204 No Content
                    - e.g:  
                            app.delete("/orders/123",async (req , res) => {
                                await orderService.remove(req.params.id);
                                res.status(204).end(); // do not use send -> send will check content-type etc.. which is not required
                            })

        - 400 vs 422 Syntax vs Semantics
            - 400 Bad Request -> "I cannot parse this request"
                - Use 400 when:
                    - JSON is malformed
                    - Required fields are missing in the request
                    - Request format is in correct.
                        - POST /orders
                            { invalid JSON } -> 400 Bad Request
            - 422 Unprocessable Entity - "Request is valid, but wrong"
                - Use 422 when:
                    - JSON is valid
                    - But values violates the business rules
                        - POST /orders
                            {
                                quantity : -5
                            }
                            -> 422 Unprocessable Entity
            - Fix 400 by correcting format
            - Fix 422 by correcting data

        - 401 vs 403 Authentication vs Authorization
            - 401 Unauthorized - "Who are you?"
                - Use 401 when:
                    - Missing token
                    - Invalid token
                    - Expires token
                        - GET /orders/123
                            { no Authorization header }
                            -> 401 Unauthorized
            - 403 Forbidden - "I know who you are(authenticated), but not allowed"
                - Use 403 when:
                    - Scope/roles missing
                        - GET /orders/123
                            (user does not own this resource)
                            -> 403 Forbidden

        - 404 vs 409 - Absence vs Conflict
            - 404 Not Found — “Resource does not exist”
                - Use 404 when;    
                    - The resource Id does not exist
                    - The URL is valid, but the resource isn't
                        - GET /orders/999
                            -> 404 Not Found
            - 409 Conflict - "State Conflict"
                - Use 409 when:
                    - The request conflict with the current state
                        - PATCH /orders/123
                            {
                                status : "shipped"
                            } 
                        - But the order is cancelled
                        - 409 Conflict
                - Mostly use it for business logic

        - 500 vs 503 - Your Fault(server) vs Temporary Failure
            - 500 Internal server error - "Bug"
                - Use 500 when
                    - unhandled exception
                    - Programming error
                    - Inconsistent state
                    - This means server is broken.
            - 503 service unavailable - "Try again later"
                - Use 503 when:
                    - Database is down
                    - Dependency is unavailable
                    - System is overloaded
                - 503 signals
                    - Temporary failure
                    - Retry must succeed
                - This is critical for :
                    - Retry logic
                    - Circuit breakers
                    - Auto Scaling
        - Status Codes Drive Client Behavior
            if(res.status >= 500) retry();
            if(res.status === 401) redirectToLogin();
            if(res.status === 422) showValidationErrors();

        - 3XX status codes - Redirection and Control Flow
            - The resource you want is somewhere else, or should be accessed differently
            - 301 Moved Permanently
                - This resource has a new permanent URL
                    - Response includes:   
                        Location /new-url
            - 302 Found (Temporary redirect)
                - This resource is temporarily available elsewhere
------------------------------------------------------------------------------------------------
6. Idempotent Keys

    - Idempotent key turn a Non-Idempotent operation into a retry-safe operation in application level.
    - Real production scenario
        - POST /orders
            1. Client sends request
            2. Server create order
            3. Server responds with 201 Created
            4. Response is lost(timeout/network issue)
            5. Client retries
        - Result
            - Two orders created
            - Same intent
            - Different IDs
    - A client generated unique identifier that represents one logical operation, regardless of how many times it is sent.
    - Client Behavior
        - Before sending a POST request
            1. Generate a unique key(UUID)
            2. Sends it in a header
                - POST /orders
                - Idempotent-key : <unique key>
    - Server behavior(high-level)
        - When the server receives a POST request with an idempotent key:
            1. Look up the key in a persistent store(redis)
            2. if does not exist:
                - Process the request
                - store the result (status + response body)
                - Associate with the key
            3. if key already exist:
                - Do not re-execute logic
                - Return the stored response
    - Where idempotency is Mandatory(Real world)
        - Payments
        - Order Creation
        - Inventory reservation
        - Email sending
        - Any side-effect-heavy POST
    - Rules
        1. key is required for POST request
        2. Same key + same user -> same result
        3. Same key + different payload -> error (important)
        - why rule #3 is important
            - Prevent accidental misuse
            - Forces correctness on the client
------------------------------------------------------------------------------------------------
7. API response structure

    - In Production environment, Consistency it the most important attribute for an API' response structure. Client can able to write single piece of code for "success" and single piece of code for "failure"
    - Client do not integrate with your code or database, they rely on response from server

    1. Consistent success response
        - Clients can predict where to find the actual data regardless of the endpoint
        - Two common patterns
            1. Bare/Flat Response(No Envelope)
                {
                    "id" : 123,
                    "status" : "created",
                    "total" : 500
                }
                - Pros
                    - simple
                    - less nesting
                    - easy for small APIs
                - Cons
                    - no place for metadata
                    - Hard to add pagination info
                    - Hard to add requester identifier
            2. Envelope Response
                {
                    "data" : {
                        "id" : 123,
                        "status" : "created",
                        "total" : 500
                    },
                    "<meta-info" : {
                        ....
                    }
                }
                - Pros
                    - Clear separation of data and metadata
                    - Easy to extend without breaking clients
                    - Consistent parsing logic
                    - Scales well with pagination, link, etc...
        - Standard success response shape
            - Canonical success format
                {
                    "data" : <RESOURCE | ARRAY>,
                    "meta" : {....} // optional
                }

                - data is always present in success response
                - meta is optional and non breaking
                - No success : true flag
            - e.g : 
                - POST /orders
                    -> 201 Created

                        {
                            "data" : {
                                "id" : 123,
                                "status" :; "created",
                                "total" : 500,
                                "customerId" : 10
                            } //RESOURCE
                        }

                - Always read response data
                - Never inspect endpoint for response (response remain consistent for API's)
                - GET /orders
                    -> 200 OK
                
                        {
                            "data" : [
                                { "id" : 123, "status" : "created" },
                                { "id" : 124, "status" : "paid" }
                            ]
                            "meta: {
                                "page" : 1,
                                "limit" : 20,
                                "total" : 124
                            }
                        }
    2. Consistent error responses
        - Canonical error response
            {
                "error" : {
                    "code" : "ORDER_NOT_FOUND",
                    "message" : "Order not found"
                }
            }
        - Rules
            - error is always present on failure response
            - code is machine-readable
            - message is human-readable
        - e.g : 
                app.get("/orders/:id" , async(req, res) => {
                    const order = await orderService.getById(req.params.id);

                    if(!order) {
                        return res.status(404).json({
                            "error" : {
                                "code" : "ORDER_NOT_FOUND",
                                "message" : "Order not found"
                            }
                        })
                    }

                    res.status(200).json({ "data" : order })
                })
------------------------------------------------------------------------------------------------
8. Error response standardization

    1. Why Error Standardization is mandatory(Not optional)
        - In productions:
            - Frontend teams write conditional logic
            - Mobile apps need localized message
            - SDKs need machine-readable signals
            - Retry logic need to know what failed
            - Observability needs clarification
        - If errors are inconsistent
            - Client parse string
            - Logic breaks on message change
            - Refactors cause regression
            - Debugging become guesswork
        - Standardization means every error must be in same shape and rule, regardless of error where it is coming from.
        - Canonical Error Response Shape.
            - For all error expect 204, we use:
                {
                    "error" : {
                        "code: "SOME_ERROR_CODE", // machine-readable
                        "message": "Human readable explanation of the error", // Human-readable
                        "details": {} //optional
                    }
                }
    
    2. Error Codes vs Error Messages
        - It is for machines
        - Error codes:
            - Are stable
            - Never localized (translation)
            - Never exposed from internal exceptions
            - Used by clients for logic
            - e.g:
                    "code" : "ORDER_NOT_FOUND"
                    
                    - CLIENT LOGIC

                            if(error.code === "ORDER_NOT_FOUND") {
                                showNotFoundUI();
                            }
        - Error Messages
            - Can change wording
            - Can be localized (translation)
            - Are shown to the users or developers
            - e.g: 
                    "message" : "order not found"
            - Never write client logic based on messages
        - Base API error code

                // Existing interface
                interface Error {
                    name: string;
                    message: string;
                    stack?: string;
                }
            
                class ApiError extends Error {
                    constructor({ code, message, status, details }){
                        super(message);
                        this.code = code;
                        this.status = status;
                        this.details = details;
                    }
                }
            
            - Example Not Found Error

                class NotFoundError extends ApiError {
                    constructor(code, message = 'Resource not found'){
                        super({
                            code,
                            message,
                            status : 404
                        })
                    }
                }

            - Usage:  
                - throw new NotFoundError("ORDER_NOT_FOUND", "order not found")
    
    3. Field-Level validation Errors
        - The error response should be clearly describe which field is failed validation and why, in a machine readable structure
        - The Problem they solve
            - POST /orders
                {
                    "quantity" : -1,
                    "price" : "abc",
                    "customerId" : null
                }
            - If API returns
                {
                    "error" : {
                        "code" : "VALIDATION_ERROR",
                        "message" : "Invalid request"
                    }
                }
                - In this client has no idea
                    - Which field is wrong
                    - What exactly is wrong
                    - How to show inline errors in UI
            - Correct error response
                {
                    "error" : {
                        "code" : "VALIDATION_ERROR"
                        "message": "Request validation failed",
                        "details" : {
                            "fields" : {
                                "quantity" : "Must be greater than 0",
                                "price" : "Must be a number",
                                "customerId" : "Required"
                            }
                        }
                    }
                }

                - client logic can be simple
                    -   if(err.code === "VALIDATION_ERROR") {
                            showInlineErrors(error.details.fields);
                        }

    4. Avoid leaking internals
        - Leaking internals happens when your API exposes:
            - Stack error*
            - SQL errors
            - File paths*
            - Library-specific messages
            - Environmental details*
        - example of bad response:
            {
                "error: {
                    "message": "cannot read property 'id' of undefined",
                    "stack": "TypeError at orderService.js:42"
                }
            }
            - This tells an attacker:  
                - Language (Node.js)
                - File structure
                - Code paths
                - Possible attack vectors
        - Client should know what went wrong, but never how it was implemented
        - Correct handling of internal errors
            - throw new Error("Database connection refused");
            - The Client should receive:
                {
                    "error: {
                        "code": "INTERNAL_SERVER_ERROR",
                        "message": "Something went wrong"
                    }
                }
            - Meanwhile, internally, you log the real error:
                - logger.error(err);
------------------------------------------------------------------------------------------------
9. Pagination strategies

    - In production, you must never allow an endpoint to return an unbounded number of resources. If a table has a million rows and a user hit GET /products, you express tries to serialize a large JSON array, Which may leads to exhausting Node.js heap memory
    - Pagination is the mechanism of returning data in discrete "chunks"
    - It is a data-access and performance control mechanism
    - If pagination is designed poorly:
        - Data slow down
        - Response become inconsistent
        - Clients see duplicates or missing data
        - Large datasets become unusable
    - In real systems
        - Orders can be in millions
        - Returning "all data" is impossible
        - Memory, CPU, network becomes bottlenecks
    - So, Pagination solves this problem, but should be handled carefully

    - Two Real Pagination strategies
        - There are only two serious approaches in productions systems:
        1. Offset-based pagination
            - Client specific:
                - How many records to skip
                - How many records to take
                - GET /orders?page=3&limit=20 -> OFFSET 40 LIMIT 20 -> offset = (page - 1) * limit = (3 - 1) * 20 = 40
                - GET /orders?offset=40&limit=20 -> OFFSET 40 LIMIT 20
                - Typical API response

                    {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "page" : 3,
                            "limit" : 20,
                            "total" : 142
                        }
                    }

                - Performance issue
                    - Scan and discard OFFSET rows
                    - Cost increases with page number
                    - Large offsets = slow query
                - Offset-based pagination is okay when:
                    - Dataset is small
                    - Data changes rarely
                    - UI requires page numbers
                    - Performance is not critical
        2. Cursor-based pagination
            - Instead of page numbers, the client uses a cursor.
                - A pointer to the last seen record
                - Usually based on a stable, indexed column
                - GET /orders?limit=20&cursor=2026-01-16T10:15:05Z
                    - "Give me the next 20 records after this cursor"

                   {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "nextCursor" : 2026-01-16T11:15:05Z,
                            "limit" : 20,
                        }
                    }

                - No page numbers, Just give me the next chunk.
            - Why cursor pagination is superior
                - Cursor pagination:    
                    - Is stable under concurrent inserts
                    - Avoids OFFSET scan
                    - Scales to millions rows
                    - Matches streaming behavior
            - Choosing a Cursor
                - A cursor must be:
                    - stable
                    - indexed
                    - Monotonic (always increasing or decreasing)
                - Good Cursor fields:
                    - createAt
                    - Auto-increment id
                    - Composite (createAt, id)
                - Bad Cursor fields:
                    - Random UUID
                    - Mutable fields
                    - Non-indexed column

            - Cursor Pagination example
                - Request
                    - GET /order?limit=20&cursor=1701418200000
                - Server logic
                    - SELECT * FROM orders WHERE created_at > cursor ORDER BY created_at ASC LIMIT 20;
                - Response
                    {
                        "data" : [/* 20 orders */],
                        "meta" : {
                            "nextCursor" : 1701418600000,
                            "limit" : 20,
                        }
                    }
------------------------------------------------------------------------------------------------
10. Filtering Strategies

    - Filtering is not about convenience, It is about controlled data access
    - Reducing a collection of resources based on conditions provided by the clients
    - GET /orders?status=paid
        - We still operate on /orders
        - We only return a subset
        - The resource identity does NOT change

    - Why Filtering is dangerous if done naively
        - Order.find(req.param)
            - Client can query any column
            - Internal fields got exposed
            - attacker can alter the schema
            - Query performance becomes unpredictable

    1. Filtering Must be Explicit
        - The Server decides what can be filtered
        - The Client only selects value
        - This leads to two strategies
            1. Allowlist (recommended)
                - You explicitly define which fields are filterable and how they can be filtered
                - Example allowed filters for an order:
                    - status
                    - customerId
                    - createdAfter
                    - createdBefore
                - GET /orders?status=paid&customerId=10
                - Logic

                         function buildOrderFilters(query) {
                            const filters = {};

                            if(query.status) {
                                filters.status = query.status
                            }

                            if(query.customerId) {
                                filters.customerId = query.customerId
                            }

                            return filters;
                         }

            2. Denylist (almost always wrong)
                - Allow everything expect these few forbidden fields.
                - Example :
                    - delete query.password;
                    - delete query.internalNotes;
                - This fails because:
                    - New fields added later exposed by default
                    - Developers forget to updated denylist
                    - security bugs are introduced silently

    2. Range-Based Filters
        - Order naturally requires ranges:
            - Date ranges
            - Amount ranges
        - Example
            - GET /orders?createdAfter=2025-12-127createdBefore=2026-02-01
            - Logic

                    function buildOrderFilters(query) {
                        const filters = {};

                        if(query.status) {
                            filters.status = query.status
                        }

                        if(query.customerId) {
                            filters.customerId = query.customerId
                        }

                        if(query.createdAfter || query.createdBefore) {
                            filters.createdAt = {};

                            if(query.createdAfter) {
                                filters.createdAt.$gt = new Date(query.createdAfter)
                            }
                        
                            if(query.createdBefore) {
                                filters.createdAt.$lt = new Date(query.createdBefore)
                            }
                        }
                         
                      return filters;
                    }

    3. Combining Filters (AND Semantics)
        - By default
            - Multiple filters are combined with AND
                - GET /orders?status=paid&customerId=10
                - Meaning
                    - Orders that are paid
                    - AND belong to customer 10
            - OR logic 
                - Must be explicit
                - Usually avoided in REST APIs

    4. Validations is Mandatory(Not Optional)
        - Filtering inputs must be validated
            - Types
            - Allowed values
            - Ranges
                - Examples
                    - status=unknown
                    - customerId=abc
                    - invalid date format
            - these should return
                - 422 Unprocessable Entity
            
    5. How Filtering fits into the request lifecycle
        - Correct lifecycle
            - Query validation
            - Filter construction
            - Database query
            - Pagination
            - Response
------------------------------------------------------------------------------------------------
11. Sorting Strategies

    - Sorting in not cosmetic, It defined determinism, pagination correctness and performance
    - It means in what deterministic order should resources be returned?
        - GET /orders?sort=createdAt&direction=desc
    - Sorting is data correctness concern, not just a UI feature

    1. API Design for sorting(Query parameter)
        - GET /orders?sort=createdAt&direction=desc
        - where
            - sort - filed name
            - direction - asc or dsc
        - Allowlist is mandatory for sorting
            - if not client can sort by any field 
            - internal field exposed
            - Unindex sorts kills performance
            - Schema leaks to client
    2. Correctness Allowlist-Based Sorting
        - Define allowed sort fields

            -   const ALLOWED_SORT_FIELDS = {
                    createdAt : 'createdAt', -> API to DB field mapping
                    totalAmount : 'totalAmount',
                    status : 'status'
                }   
            - validate sort direction
                - Allowed values:
                    - asc
                    - desc
                - Anything else -> error
                - Logic

                        function buildOrderSort(query) {
                            const sort = {};
                            const field = query.sort || 'createdAt';
                            const direction = query.direction || 'desc';

                            if(!ALLOWED_SORT_FIELDS[field]) {
                                throw new ValidationError({
                                    sort : "Invalid sort field"
                                })
                            }

                            if(!['asc' , 'desc' ].includes(direction)) {
                                throw new ValidationError({
                                    direction : "Must be asc or desc"
                                })
                            }

                            sort[]ALLOWED_SORT_FIELDS[field] = direction === 'asc' ? 1 or -1; //default DESC 

                            return sort;
                        }
        3. Sorting + Pagination (Critical Pagination)
            - Offset Pagination
                - Sorting must be stable
                - Same sort must be applied next page
            - Cursor Pagination
                - cursor field must match sort field
                - cursor must move in the same direction
                - Example
                    - GET  /orders?limit=20&cursor=17638040000
                    - WHERE createdAt < cursor ORDER BY createAt desc
        4. Multi-Field Sorting (advanced)
            - sort=createdAt,status
        5. Performance
            - Sorting is only fast if
                - Field is indexed
                - Direction matched index
                - Database size is manageable
            - Allowlisting let us:
                - Ensure indexes exist
                - Prevent additional slow queries
        6. How Sorting fits into the request lifecycle
            - Request
                - Query validation
                - Filter construction  -> Where status = 'paid'
                - Sort construction -> order by createdAt desc
                - Pagination -> limit 20
                - Database query
                - Response
            - Sorting must apply 
                - After filtering
                - before pagination
------------------------------------------------------------------------------------------------
12. Filtering -> Sorting -> Pagination
    - Filter -> where
    - Sort -> order by
    - pagination -> limit

    - GET /orders
            ?status=paid
            &customerId=12
            &createdAfter=2026-01-01
            &sort=createdAt
            &direction=desc
            &limit=20
            &cursor=17010182000

    1. Filtering
        - Query param used for Filtering
        - status = paid & customerId = 12 & createdAfter = 2026-01-01
        - Give me the orders that paid belongs to the customer 12 were created after 2026-01-01
        {
            status : "paid",
            customerId : 12
            createdAt : {
                $gt : new Date('2026-01-01T00:00:00Z')
            }
        }

    2. Sorting
        - Query param used for sorting
        - status=createdAt & direction=desc
        - Sort order by creation time, newest first"
        {
            createdAt : -1;
        }
        
    3. Pagination
        - Query param used for Pagination
        - limit = 20
        - cursor = 17010182000
        - “Give me 20 orders created before timestamp 1704105600000”
        {
            createdAt : { $lt : new Date(cursor)}
        }

    - Incoming Request
            │
            ├─▶ Query validation
            │    ├─ validate status enum
            │    ├─ validate customerId number
            │    ├─ validate date formats
            │    ├─ validate sort field & direction
            │    └─ validate limit & cursor
            │
            ├─▶ Build filters
            │
            ├─▶ Build sort
            │
            ├─▶ Apply cursor pagination
            │
            ├─▶ Database query
            │
            └─▶ Response

    - Final SQL query
        - SELECT *
            FROM orders
            WHERE
            status = 'paid'
            AND customer_id = 42
            AND created_at > '2024-01-01'
            AND created_at < cursor
            ORDER BY created_at DESC
            LIMIT 20;

    - Response Shape
        {
            "data": [
                {
                "id": 891,
                "status": "paid",
                "customerId": 42,
                "totalAmount": 1200,
                "createdAt": "2024-02-10T10:12:45Z"
                }
            ],
            "meta": {
                "limit": 20,
                "nextCursor": "2024-02-10T10:12:45Z"
            }
        }

        - /api/orders?status=paid&customerId=123&createdAfter=2026-01-01T00:00:00Z&limit=5&sort=createdAt&direction=desc&cursor=2026-01-01T02:01:00Z
                {
                finalQuery: {
                    status: 'paid',
                    customerId: '123',
                    createdAt: {
                    '$gt': 2026-01-01T00:00:00.000Z,
                    '$lt': 2026-01-01T02:01:00.000Z
                    }
                },
                sort: { createdAt: -1 },
                limit: 5
                }
            - createdAt < cursor -> sortOrder is desc
            - createdAfter = 2026-01-01T00:00:00Z
            - cursor = 2026-01-01T02:01:00Z

        - /api/orders?status=paid&customerId=123&createdBefore=2026-01-01T02:00:00Z&limit=5&sort=createdAt&direction=asc&cursor=2026-01-01T01:01:00Z
                {
                finalQuery: {
                    status: 'paid',
                    customerId: '123',
                    createdAt: {
                    '$lt': 2026-01-01T02:00:00.000Z,
                    '$gt': 2026-01-01T01:01:00.000Z
                    }
                },
                sort: { createdAt: 1 },
                limit: 5
                }
            - createdAt > cursor -> sortOrder is asc
            - createdBefore = 2026-01-01T02:00:00Z
            - cursor = 2026-01-01T01:01:00Z


        | Sort | Static filter | Cursor condition | Valid                                   |
        | ---- | ------------- | ---------------- | --------------------------------------- |
        | DESC | createdAfter  | `< cursor`       | ✅                                      |
        | DESC | createdBefore | `< cursor`       | ⚠️ (must ensure cursor < createdBefore) |
        | ASC  | createdBefore | `> cursor`       | ✅                                      |
        | ASC  | createdAfter  | `> cursor`       | ⚠️ (must ensure cursor > createdAfter)  |
------------------------------------------------------------------------------------------------
13. Validation Fundamentals
    
    - Validation is the act of proving that incoming request is acceptable before your system trusts it.
        - Checking if data looks fine
        - Making typescript happy
        - Preventing crashes
    - In HTTP request, every single external input is untrusted
    - Validation = contract enforcement
    - Schema = legal document
    - middleware = gatekeeper
    - Controller = assume validity
    - unknown field = rejected
    - defaults = applied early
    - That includes :

        1. Request body (req.body)
            {
                quantity : -5,
                prices : free,
                customerId : null,
            }
            - Question you must answer:
                - Is Quantity a positive number?
                - Is price is a number?
                - Is customerId present and valid?

        2. Query parameters (req.query)
            - GET /orders?limit=1000000&sort=DROP_TABLE
            - Questions
                - Is limit with allowed bounds?
                - Is sort one of the allowed list?
                - Is direction valid(asc/desc)?

        3. Route params (req.params)
            - GET /orders/abc123
            - Questions
                - Is this a valid UUID?
                - Is this format expected by DB?
                - Could this cause a DB error or injection?

        4. Headers (often forgotten)
            - Idempotency-key : <empty>
            - Authorization : Bearer <token>
            - Headers can
                - Break auth
                - Break caching
                - Break idempotency guarantees

    1. Why validation must be middleware
        - Express execution model
            - Request -> Middleware chain -> Controller -> Service -> Response
        - Middleware runs before Controller
        - why middleware?
            1. Single responsibility
            2. Controller must assume valid input
            3. Centralized failure behavior

                router.post(
                    "/orders",
                    validateCreateOrder, //validation middleware
                    createOrderController //business logic
                )

    2. Fail-Fast principle
        - Fail as early as possible, with the least cost and with clear intent.
        - It prevents
            - wasted resources
            - data corruption
            - security issues

    3. Validation is also a security boundary
        - validation protects against:
            - Mass assignment attacks
            - Unexpected fields
            - Type confusion bugs
            - Injection vectors(indirectly)
                - Example :
                    {
                        quantity : 2,
                        price : 100,
                        status: "SHIPPED" //client should not set this
                        isAdmin : true // malicious attempt
                    }
------------------------------------------------------------------------------------------------
14. Validation with Joi / Zod
    
    - Validation is the act of enforcing a strict input contract at the system boundary.
        - Is this request even allowed to be processed by my system ?
        - It does not answer:
            - Whether the user is allowed(authorization)
            - Whether the operation is possible(business logic)
            - Whether the resource exit (service layer)
        - Those happen after input validation
    
    1. What is a Schema?
        - A schema is a formal, machine-enforced contract that defines:
            - Which fields are allowed?
            - Which fields are required?
            - The data type of each field
            - Constraints (min, max, enum, format)
            - Defaults
            - Whether extra fields are rejected
        - Think of a schema as:
            - The legal document that defines what clients permitted to say.
        
    2. Why Joi/Zod exist at all?
        - Javascript is:
            - Dynamically typed
            - Forgiving
            - Accept almost anything at runtime
        - HTTP input is:
            - Text-based
            - untrusted
            - User-controlled
        - Schema validators are exist to close these gaps

    3. Why schema validation is required
        - A client sends:
            {
                "quantity" : "2",
                "price" : "100",
                "status" : "SHIPPED"
            }
            - without schema validation
                - "2" is treated as truthy
                - "100" passes through
                - status silently overwrites internal state
            - In a result:
                - Orders appear shipped without payment
                - inventory mismatches
                - Financial reconciliation breaks
            
    4. Input validation 
        1. Body validation:
            - Large payloads
            - Nested Objects
            - Can mutate internal state
            - Common vector mass assignment attacks
            - Examples :
                            {
                                "customerId: "uuid"
                                "items" : [
                                    { "productId":"uuid" , "quantity" : 2 }
                                ]
                                "note" : "Leave at door",
                                "status" : "SHIPPED" //client should never send this
                            }

            - Schema design thinking
                - Should extra fields allowed? -> NO
                - Should client set the status? -> NO
                - Can items be empty -> No
                - Can quantity can zero or negative -> NO

                    const createOrderBodySchema = Joi.object({
                        "customerId" : Joi.string().uuid().required(),
                        "items" : Joi.array().items(
                            {
                                "productId" : Joi.string().uuid().required(),
                                "quantity" : Joi.number().min(1).required()
                            }
                        ).min(1).required(),
                        "note" : Joi.string().max(500).optional(),
                    }).required().unknown(false)
                
                - unknown(false) 
                    - is critical to reject undeclared fields
                    - prevent mass assignments
                    - Force explicit API contracts

        2. Query validation:
            - All query params arrive as string, Even if the client sends a number.
            - GET /orders?limit=1000&sort=createdAt&direction=desc
                - limit: integer, bounded
                - sort: allowlisted fields only
                - direction: enum
                - cursor: opaque string

                    const listOrdersQuerySchema = Joi.object({
                        "limit": Joi.number().integer().min(1).max(100).default(20),

                        "sort": Joi.string()
                            .valid("createdAt" , "totalAmount")
                            .default("createdAt")
                        
                        "direction": Joi.string()
                            .enum("asc" , "desc")
                            .default("asc"),
                        
                        "cursor": Joi.string().optional(),
                    }).unknown(false);

        3. Param validation:
            - GET /orders/:orderId
            - If orderId is invalid
                - DB throw error
                - Error becomes 500
                - Internal details leak

                    const orderIdParamSchema = Joi.object({
                        "orderId": Joi.string().uuid().required,
                    })

                - This ensure:
                    - Only valid identifiers reach DB layer
                    - Errors are client-correct (400, not 500)
                    - No wasted DB work

        4. Validation Middleware Pattern
            - middleware runs before controllers
            - enables fail-fast
            - centralizes behavior
            - keeps controllers clean
            - Generic validation middleware

                function validateBody(schema) {
                    return (req, res, next) => {
                        const { error , value } = schema.validate(req.body, {
                            abortEarly; false,
                            stripUnknown : true
                        })

                        if(error) {
                            throw new ValidationError(error.details)
                        }

                        req.body = value;

                        next()
                    }
                }
            - with abortEarly: false
                - Client receives all errors at once
------------------------------------------------------------------------------------------------
15. Centralized error handling  

    1. Concept Definition — What Is Centralized Error Handling? (First Principles)
        - It is a system-wise mechanism where all errors, regardless of where it is coming from, are transformed into a consistent, controlled HTTP response at single place in the application
        - Instead every route decides how to fail, the application has one authority that decides how failures are communicated to clients
        - In Express, this authority is implemented using a single error-handling middleware

    2. Why Centralized Error handling is required
        - Imagine three endpoints in your API:
            - POST /orders
            - GET /orders/:id
            - DELETE /orders/:id
        - Each developer handles error differently
            - res.status(400).send("Invalid input")
            - res.status(500).json({ message : err.message })
            - res.send(err)

            - What happens in reality
                - Clients cannot rely on error formats
                - Frontend breaks on unexpected responses
                - Monitoring tools cannot classify failure
                - Sensitive error messages leak to users
                - Debugging production becomes guess works

    3. Operational Errors vs Programmers Errors
        1. Operational Errors
            - Operational errors are failures that are expected to happen in running system
            - Examples
                - Invalid request data
                - Resource not found
                - Authentication failure
                - Business rule violation
            - Characteristics
                - Caused by user input or environment
                - Should be handled gracefully
                - Should result in controlled HTTP response
            - These are safe to expose
        
        2. Programmer Errors
            - Programmer errors are mistakes in code logic(bugs)
            - Examples
                - Accessing undefined.property
                - Null pointer errors
                - Incorrect assumptions in code
                - Broken invariants
            - Characteristics
                - Should NOT be exposed to clients
                - Indicate bugs, not client mistakes
                - Require fixing, not retrying
            - Programmer errors must become generic 500 errors, never detailed responses.
    
    4. Summary
        - Errors are part of system design, not accidents
        - Operational errors are expected and controlled
        - Program errors are hidden and logged
        - Custom error classes encode meaning
        - One centralized handler own all error responses
        - Controller never format errors
------------------------------------------------------------------------------------------------
16. Authentication & Authorization

    1. What is Authentication?
        - It is the process of *proving the identity of a client* to make request to the server
        - In REST APIs, authentication is typically done using:
            - Token(most common)
            - API keys
            - Certificates (rare for public APIs)
        - who you are ?
    
    2. What is Authorization?
        - Authorization is the process of deciding whether an authenticated identity is allowed to perform a specific action on a specific resource.
        - Authorization always depends on authentication
        - what you are allowed to do

    3. Authentication Responsibilities
        - Authentication must :
            - Extract credentials from the request.
            - Validate those credentials
            - Resolve the trusted identity
            - Attach that identity to the request context
        - In Express terms:
            - Authentication middleware is responsible for population req.user

    4. Token-Based Authentication
        - REST APIs are stateless by design
        - That means:
            - Server does not remember clients between requests
            - Every request must carry proof of identity
        - Typical token flow
            1. Client logs in
            2. Server issue a token
            3. Client sends that token on every request
            4. Server verifies token
            5. Identity reconstructed
        - No sessions, No server memory, Fully stateless

    5. Authentication Middleware

            function authenticate(req, res, next) {
                const authHeader = req.headers.authorization;

                if(!authHeader) {
                    return next(
                        new ApiError({
                            statusCode: 401,
                            code: "UNAUTHENTICATED",
                            message : "Authentication required"
                        })
                    )
                }
                /**
                *   Logic for user validation and extract user info
                /
                req.user = {
                    id : "user-id",
                    role : "customer"
                }

                next()
            }
    
    6. Authorization Responsibilities
        - Authorization must:
            - Assume req.user already exist
            - Evaluate permissions or ownership
            - Decide allow or deny
            - Fail with a 403 Forbidden, not 401
        - Authorization is always context-dependent:
            - Resource
            - Action
            - Identity
            - Business rules
        Authorization concern: 
            - Check ownership
            - Check permissions
            - Decide business rules
            - Access application data unnecessarily
------------------------------------------------------------------------------------------------
17. Caching strategies (HTTP Layer)
    
    - Caching is the controlled use of previous generated data to avoid recomputation and reduce latency, load, and cost.

    1. In HTTP systems, caching means:
        - The Sever tells intermediaries(middleman)(Browser, CDN, proxy) 
        - When a response can be reused
        - For whom, it may be reused
        - Under what condition it must be revalidated
        - Caching is not an optimization trick
        - It is part of HTTP Contract

    2. Why Caching is required ?
        - Without caching, every request:
            - Hits your Node.js server
            - Hits your database
            - Consumes CPU, memory, and network
            - Scaled linearly with traffic
        - In real production systems
            - 80-90% of traffic is read traffic
            - Most reads requests identical data
            - Recomputing identical responses is wasteful

    3. Critical Rule - Caching is About Correctness First
        - It is not about speed, This mindset causes bugs.
            - Correct caching means:
                - Never serving another user's private data.
                - Never serve stale data when freshness matters
                - Never bypassing authorization rules
        - At fast wrong response is worse than a slow correct response
        
    4. Sub topics

        1. HTTP caching vs application caching
            1.a HTTP Caching
                - Happens outside your code
                - Implemented by browsers, CDN, proxies
                - Controlled via headers
                - stateless and scalable
                - Examples:
                    - Browser cache
                    - CDN(cloudflare, Fastly)
                    - Reverse proxy
            1.b Application caching
                - Happens inside your system
                - Redis, memory, etc..
                - requires invalidation strategies
                - Harder to get right
            - HTTP caching should always come first
            - If HTTP caching goes wrong, internal caching only amplifies mistakes.

        2. Cache-Control Header (Core of HTTP caching)
            2.a Cache-Control is an instruction set sent by the server that tells caches:
                - Whether they may store the response
                - For how long
                - Under what conditions
                - Examples:
                    - Cache-Control: max-age=60 
                    - This means the response may be reused for 60 seconds without contacting the server.
            2.b Common directive
                - no-store
                    - Do not store any response anywhere
                    - used for sensitive data
                - no-cache
                    - Cache may store response
                    - Must revalidate before reuse
                - max-age=seconds
                    - Response is fresh for given time
                - private
                    - Only browser may cache
                    - Shared caches must not
                - public
                    - Any cache may store

        3. Public vs private responses (security critical)
            3.a Public response
                - Same for all users
                - Safe to share
                    - Example: Product catalog
                - Cache-Control: public, max-age=300
            3.b Private response
                - User-specific
                - Must never be shared
                    - Example : users orders
                - Cache-Control: private, no-cache

        4. ETag and Conditional requests
            4.a. What is an ETag?
                - An ETag is a version identifier for the resource
                    - Example: "order-list-v42"
                - The client later sends:
                    - If-None-Match: "order-list-v42"
            4.b Server behavior
                - If resource unchanged -> 304 Not Modified
                - If Changed -> 200 Ok with new body

                This:
                    - Saves bandwidth
                    - Preserves correctness
                    - Avoid stale responses
                    - Why ETag is better than blind caching
                        - Time-based caching guesses freshness
                        - ETag verifies freshness
                    - That matters when:
                        - Orders changes frequently
                        - Multiple clients update data
                        - Accuracy is critical

        5. Authentication and Caching interaction
            - Authenticated responses are private by default
            - For endpoints like
                - GET /orders
                - GET /orders:id
            - Correct headers:
                - Cache-Control: private, no-cache
            - Why:
                - Response depends on req.user
                - Shares must not be used
                - Browser may cache, but must revalidate

            res.set("Cache-Control", "private, no-cache");
            res.set("ETag", ordersEtag);
            res.json({ data: orders });

            - Private? → “Is this user-specific?”
            - No-cache? → “Must I ask the server before reuse?”
            - ETag? → “Has it changed?”

        6. What Problem Do ETag and If-None-Match solve ?
            - ETag and If-None-Match together solves the problem of safely reusing data without guessing whether it is stale
            - More Precisely:
                - They allow a client to ask the server:
                    - "Has this resource changed since the last time i saw it?"
                - If the answer is no, the server sending the response body again
                - If the answer is yes, the server sends the updated representation.
            - This is called conditional requests, and it it a core part of HTTP correctness.
            - ETag does not exist by default
            - It is introduced after the first successful response
            - Cache-Control decides IF reuse is allowed.
            - ETag decides WHETHER reuse is still valid.

            - Revalidation means the cache is not allowed to use its stored response without first asking the origin server whether that response is still valid.

            - Shared cache is a cache that serves multiple users, not just one.
                - CDN
                - Reverse proxy(nginx, varnish)
                - Corporate proxy
                - ISP cache
------------------------------------------------------------------------------------------------
18. Rate Limiting
    
    - It is a mechanism that restrict how many requests that a client allowed to make within a defined time window.
    - Rate Limiting protects system capacity

    - Without Rate Limiting
        - A frontend bug causes:
            - A retry loop
            - 50 requests per second per user
            - Thousands of users affected
        - Result:
            - Database connection pool exhausts
            - Latency spikes
            - Healthy users are impacted
            - System appears "down"

    - Rate Limiting also protects against:
        - Brute force attacks
        - Credentials stuffing
        - Token guessing
        - Enumerations attacks

    - sub topics

        1. What problem rate limiting actually solves

            1.a Rate Limiting protects:
                - CPU
                - Memory
                - Database connections
                - Downstream services
            1.b It does not   
                - Make code faster
                - Fix inefficient queries
                - Replace caching
                - Replace authentication

        2. IP-Based vs User-Based Rate Limiting

            2.a IP-Based Rate Limiting
                - IP Based rate limiting limits request for IP address.
                - Examples:
                    - Allow 100 request per minute per IP.
                - Why it is exist
                    - Works before authentication
                    - Protects public endpoints
                    - Cheap and simple
            
            2.b User-Based Rate Limiting
                - User-Based rate limiting limits request for authenticated identity.
                - Example rule:
                    - Allow 1,000 requests per minute per user.
                - Why this is more accurate
                    - Tied to real identity
                    - Fair usage per customer
                    - Works even behind shared IPs
        
        3. Rate Limiting Algorithms

            3.a Fixed window
                - Count requests in a fixed time bucket
                - Reset counter every window
                - Example:
                    - 100 requests per minute
                    - Counter resets every minute
                - Problem
                    - Traffic bursts at window edges:
                        - at 59th sec -> 100 requests
                        - at 61th sec -> 100 requests
                        - 200 requests in 2 seconds

            2.b Sliding window
                - Requests spread over rolling time window
                - No sharp reset boundary
                - This:
                    - Smooths traffic
                    - Prevents bursts
                    - Better reflects real usage
                - Most modern systems use sliding windows or token buckets

        4. Correct HTTP behavior when Rate Limit is Exceeded

            - Status code (non-negotiable)
            - 429 Too Many Requests 
                - This tells the client that "you are sending requests too fast"
            - Important response headers : Retry-After: 60
                - Client should wait 60 seconds before retrying

        5. Express Rate Limiting Middleware

            - What rate limiting middleware must do
                - Identify the client(IP or User)
                - Track request counts
                - Decide allow/deny
                - Fail fast
                - Never reach controllers on violation

            function rateLimit({keyGenerator, limit, windowMs}) {
                return (req, res, next) => {
                    const key = keyGenerator(req);

                    const isAllowed = checkAndIncrement(key, limit, windowMs);


                    if(!isAllowed){
                        res.set("Retry-After", Math.ceil(windowMs/1000));
                        
                        return next(
                            new ApiError({
                                statusCode: 429,
                                code: "RATE_LIMIT_EXCEEDED",
                                message: "Too many request, please try again later"
                            })
                        )
                    }

                    next();
                }
            }

            - This middleware:
                - Is reusable
                - Is deterministic
                - Integrates with centralized error handling

        6. Middleware order

            - Request
                -> IP rate limit
                -> Authentication
                -> User rate limit
                -> Authorization
                -> Validation
                -> Controller


------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
